Завдання в цілому аналогічне завданням «Структура (колекція) set» та
«Структура (колекція) set від власного типу --- 1» (і наполегливо
рекомендується зробити спочатку їх, саме в такому порядку), але
елементами повинні бути не числа, а дещо складніші об'єкти:
прямокутники, кожен з яких описується довжинами двох своїх сторін *a*,
*b* (два цілі числа) та кольором (`string`) *col*.

Cлід постійно підтримувати чотири множини, виходячи з таких чотирьох
можливих трактувань задачі:

1.  повертати прямокутники заборонено (довжина повинна бути довжиною,
    ширина повинна бути шириною), колір враховується; інакше кажучи,
    елемент-прямокутник належить множині тоді й тільки тоді, коли
    множина містить елемент-прямокутник, в якого такі самі довжина і
    ширина (в такому самому порядку), причому такого самого кольору (в
    смислі звичайної case-sensitive рівності рядків);

2.  повертати прямокутники заборонено (довжина повинна бути довжиною,
    ширина повинна бути шириною), колір ігнорується; інакше кажучи,
    елемент-прямокутник належить множині тоді й тільки тоді, коли
    множина містить елемент-прямокутник, в якого такі самі довжина і
    ширина (в такому самому порядку), але колір не перевіряється, може
    бути хоч однаковим, хоч різним;

3.  повертати прямокутники дозволено (можна хоч залишити довжину
    довжиною та ширину шириною, хоч повернути, зробивши довжину шириною
    та ширину довжиною), колір враховується; інакше кажучи,
    елемент-прямокутник належить множині тоді й тільки тоді, коли
    множина містить елемент-прямокутник, в якого такі самі розміри, але
    порядок цих розмірів може бути хоч таким самим, хоч переставленим;
    при цьому колір повинен бути таким самим (у смислі звичайної
    case-sensitive рівності рядків);

4.  повертати прямокутники дозволено (можна хоч залишити довжину
    довжиною та ширину шириною, хоч повернути, зробивши довжину шириною
    та ширину довжиною), колір ігнорується; інакше кажучи,
    елемент-прямокутник належить множині тоді й тільки тоді, коли
    множина містить елемент-прямокутник, в якого такі самі розміри, але
    порядок цих розмірів може бути хоч таким самим, хоч переставленим;
    при цьому колір не перевіряється, може бути хоч однаковим, хоч
    різним.

(див. також пояснення до прикладів).

Кожен із запитів `ADD` та/або `PRESENT` має по три параметри *a b col*,
саме в такому порядку. Вони задаються в одному рядку через пробіли.

Напишіть програму, яка виконуватиме послідовність запитів виду `ADD` *a
b col*, `PRESENT` *a b col* та `COUNT` (без параметрів). Програму
обов'язково слід писати за допомогою бібліотечного типу (колекції) set
(її реалізації в конкретних мовах програмування можуть називатися
`HashSet`, `TreeSet`, `SortedSet`, ...).

Виконання кожного запиту виду `ADD` *a b col* повинно додавати
прямокутник до всіх чотирьох множин (якщо такий само прямокутник вже є,
додавання ще однієї копії не змінює множину; слід розуміти, що можливі
ситуації, коли з точки зору деяких із трактувань 1, 2, 3, 4 такий
прямокутник вже є й додавання ще однієї копії не змінить множину, а з
точки зору інших трактувань такого прямокутника нема і його слід
обов'язково додати). На екран при цьому нічого не виводиться.

При виконанні кожного запиту виду `PRESENT` *a b col* повинно видаватися
рівно чотири повідомлення «`YES`» чи «`NO`» (великими літерами, в одному
рядку через пробіли, без лапок), на позначення того, чи наявний такий
прямокутник у кожній з цих множин, згідно описаних вище трактувань 1, 2,
3, 4, саме в такому порядку. Значення множин при цьому не змінюються.

При виконанні кожного запиту виду `COUNT` повинно видаватися (цифрами, в
одному рядку через пробіли) рівно чотири кількості елементів, згідно
описаних вище трактувань 1, 2, 3, 4, саме в такому порядку. Значення
множин при цьому не змінюються.

У першому рядку задано кількість запитів $N$
($5\leqslant N\leqslant 2\cdot10^5$), далі йдуть $N$ рядків, кожен з
яких містить по одному запиту згідно з описаним форматом. Всі параметри
*a* та *b* є цілими числами від 1 до 1234567890. Всі параметри *col* є
рядками, що містять від 1 до 15 латинських (англійських) літер, без
будь-яких інших символів.

Виводьте на стандартний вихід (екран) в окремих рядках результати
запитів `PRESENT` (рівно чотири «`YES`» чи «`NO`» великими літерами, в
одному рядку через пробіли, без лапок) та COUNT (рівно чотири числа, в
одному рядку через пробіли); на запити ADD нічого виводити не слід.

::: example
:::

Перша відповідь `1 1 1 1` правильна, бо для будь-якого трактування
правильно, що в той' момент множина містить рівно один
елемент-прямокутник `5 2 red`.

Друга відповідь `YES YES YES YES` правильна, бо коли питають про
наявність прямокутника, з такими самими розмірами `5 2` в такому ж
порядку, причому такого самого кольору `red`, то за будь-яким з
трактувань він вже наявний.

Третя відповідь `NO YES NO YES` правильна, бо коли розміри `5 2` такі
самі в такому ж порядку, але колір інший (case-sensitive передбачає, що
`ReD` не дорівнює `red`), то лише за трактуваннями 2 та 4, які ігнорують
колір, можна вважати, що такий прямокутник вже є.

Четверта відповідь `NO NO YES YES` правильна, бо коли розміри `2 5` є
тими самим числами, але в іншому порядку, то лише за трактуваннями, які
дозволяють повертати прямокутник, тобто трактуванням 3 (враховуючи
однаковість кольору `red`) та 4, можна вважати, що такий прямокутник
вже є.

П'ята відповідь 2 2 2 1 правильна, бо за трактуванням 4 розміри 2 5
рівноцінні розмірам 5 2, а колір не перевіряється, тому додавання ще
однієї копії не змінює множину у трактуванні 4; за будь-яким іншим
трактуванням або одна, або обидві з причин «в уже наявного прямокутника
інший колір, тому цей новий» та/або «в уже наявного прямокутника розміри
в іншому порядку, тому цей новий» роблять необхідним додавання нового
елемента-прямокуника.

Шоста відповідь 3 2 2 1 правильна, бо за трактуванням 1 прямокутник 2 5
red новий і його треба додати, тоді як за всіма іншими трактуваннями
такий прямокутник вже був (як 2 5 green або 5 2 red).

Сьома відповідь NO NO NO NO правильна, бо нічого досить схожого на
прямокутник 7 17 yellow раніше не згадувалося, навіть якщо дозволяти
переставляння сторін місцями та/або ігнорування кольору.

Восьма відповідь 4 3 3 2 правильна, бо прямокутник 3 3 brown (який є
також квадратом, але це неважливо) є новим за всіма трактуваннями і його
треба додати.

Абсолютно повне виконання завдання передбачає, що воно виконане і через
бібліотечну колекцію HashSet (з написанням власних GetHashCode та
Equals), і через бібліотечну колекцію SortedSet (з написанням власного
компаратора). Само собою, можна виконати частину, на відповідну частину
балів.

Рекомендується описати чотири різні власні класи, які відповідають
прямокутникам згідно кожного з чотирьох трактувань. Чи організовувати їх
так, щоб якісь з них були нащадками інших, чи робити, щоб вони всі були
нащадками одного абстрактного класу, чи ще якось; чи користуватися
поліморфізмом --- все це повністю на вибір студента. ООП взагалі не є
предметом розгляду курсу «Алгоритми та структури даних». Якщо вдасться
зробити завдання, використавши лише лямбда-функції без написання
чотирьох різних власних класів --- теж можна. Але навряд чи вийде
зробити це завдання, взагалі не використавши ні власні класи, ні
лямбда-функції.)

Перша відповідь `1` правильна, бо на той момент множина містить рівно
один елемент-прямокутник `5 2 red`.

Друга відповідь `YES` правильна, бо коли питають про наявність
прямокутника, з такими самими розмірами `5 2` в такому ж порядку,
причому такого самого кольору `red`, то він вже наявний.

Третя відповідь `NO` правильна, бо хоч розміри `5 2` такі самі в такому
ж порядку, але колір інший (case-sensitive передбачає, що `ReD` не
дорівнює `red`).

Четверта відповідь `YES` правильна, бо розміри `2 5` і є тими самим
числами (хоч і в іншому порядку), що й `5 2`, і колір правильний.

П'ята відповідь `2` правильна, бо перед тим був запит `ADD` з
елементом-прямокутником, що відрізняється від вже наявного кольором,
тому тоді його додали, від чого кількість елементів множини змінилася.

Шоста відповідь `2` правильна, бо перед тим був запит `ADD` з
елементом-прямокутником `2 5 red`, що (незважаючи на переставляння
місцями чисел) вважається рівним одному з уже наявних у множині
прямокутників `5 2 red`, тому множина не змінилася й продовжує містити
рівно 2 елементи-прямокутники.

Сьома відповідь `2` правильна, бо перед тим був запит `ADD` з
елементом-прямокутником, за всіма ознаками рівним вже наявному
(найпершому) елементу-прямокутнику, тому множина не змінилася й
продовжує містити рівно 2 елементи-прямокутники.

Абсолютно повне виконання завдання передбачає, що воно виконане і через
бібліотечну колекцію `HashSet` (з написанням власних `GetHashCode` та
`Equals`), і через бібліотечну колекцію `SortedSet` (з написанням
власного компаратора). В разі виконання іншою мовою програмування,
з'ясуйте відповідні деталі самостійно, але це повинен бути бібліотечний
спосіб через хеш-таблиці та бібліотечний спосіб через дерева. Само
собою, можна виконати частину, на відповідну частину балів.
