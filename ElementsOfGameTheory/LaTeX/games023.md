Кількакрокова послідовна гра на дереві рішень відбувається так: спочатку
1-й гравець повинен прийняти рішення, вибравши один з можливих варіантів
свого ходу; деякі з цих варіантів ходу можуть відразу мати числові
значення, скільки від того виграв 1-й гравець і скільки 2-й, решта
передбачають, що тепер повинен прийняти рішення (вибрати варіант свого
ходу) 2-й гравець, вже знаючи, яке рішення перед тим прийняв (який
варіант свого ходу вибрав) 1-й гравець. Серед варіантів ходу 2-го гравця
теж деякі можуть мати готові числові значення, скільки від того виграв
1-й гравець і скільки 2-й, а решта передбачати, що тепер повинен
прийняти рішення (вибрати варіант свого ходу) знову 1-й гравець. І так
далі.

(Цю схему можна узагальнити на більшу кількість гравців, але в цій
задачі гравців рівно двоє, й рішення приймають спочатку 1-й, потім 2-й,
потім 1-й, потім 2-й, ...)

Всі гілки такого д*е*рева мусять колись закінчитися «листками» з
готовими числовими значеннями, скільки виграв 1-й гравець і скільки 2-й,
але шляхи від кореня (початкового вибору 1-го гравця) до різних
«листків» є різними, й кількості проміжних вершин-рішень у цих різних
шляхах можуть бути різними (однаковими теж можуть).

Єдиний рядок, який містить дерево, закодоване таким способом:

1.  кожен окремий вузол-«листок» подається у вигляді $(p_1\,\,\,p_2)$,
    тобто: відкривна кругла дужка, величина виграшу 1-го гравця, пробіл,
    величина виграшу 2-го гравця, закривна кругла дужка;

2.  кожен вузол, що не є «листком» (отже, в ньому приймається рішення й
    різні варіанти ведуть до різних подальших вузлів) подається у
    вигляді: відкривна квадратна (якщо ходить 1-й гравець) чи кутова
    (якщо 2-й) дужка, пробіл, код вузла, куди веде перший варіант
    рішення, пробіл, код вузла, куди веде др*у*гий варіант рішення,
    пробіл, ..., код вузла, куди веде останній варіант рішення, пробіл,
    закривна квадратна чи кутова дужка (так само, `]` для 1-го і `>` для
    2-го). При цьому вкладені коди вузлів можуть відповідати чи то
    попередньому пункту (якщо вони вже не мають розгалужень), чи то
    поточному (якщо мають).

Наприклад, `[ (2 3) (4 5) (6 1) ]` подає дерево, де єдиний проміжний
вузол має розгалуження на три варіанти, які всі є «листками», виграші
яких становлять 2 для 1-го і 3 для 2-го, 4 для 1-го і 5 для 2-го, 6 для
1-го і 1 для 2-го.

Гарантовано, що:

1.  дерево містить щонайменше один вузол;

2.  рядок, що кодує дерево, має не більше $10^5$ символів (усіх, включно
    з пробілами та дужками);

3.  для проміжних вузлів, кількість варіантів вибору перебуває в межах
    від 2 до 6;

4.  всі виграші обох гравців (рахуючи по всім вузлам-«листкам») є
    різними числами, кожне з яких поміщається у 32-бітовий знаковий

Програма виводить два числа в одному рядку, розділені пропуском:
виграші, які мають отримати 1-й та 2-й гравці відповідно, якщо
застосувати описаний алгоритм зворотньої індукції.

::: scriptsize
::: examplewide
:::
:::
