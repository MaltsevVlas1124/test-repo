::: problem
Палички --- інтерактивна граСтандартний вхід (клавіатура)Стандартний
вихід (екран)1 сек64 Мб[]{#text:sticks-simple-begin
label="text:sticks-simple-begin"}
[]{#prob:201819-oioi-C-sticks-simple-interactive
label="prob:201819-oioi-C-sticks-simple-interactive"}

Є одна купка, яка спочатку містить $N$ паличок. Двоє грають у таку гру.
Кожен з гравців на кожному своєму ході може забрати з купки або 1,
або 2, або 3 палички. Ніяких інших варіантів ходу нема. Ходять гравці по
черзі, пропускати хід не можна. Виграє той, хто забирає останню паличку
(можливо, разом із ще однією або ще двома).

Напишіть програму, яка інтерактивно гратиме за першого гравця.

На початку, один раз, Ваша програма повинна прочитати одне ціле число в
окремому рядку--- початкову кількість паличок $N$
(${1\,{\<}\,N\,{\<}\,12345}$). Потім вона повинна повторювати такий
цикл:

1.  Вивести єдине число в окремому рядку--- свій хід, тобто кількість
    паличок, які вона зараз забирає з купки. Цеповинно бути ціле число
    від 1 до 3, не більше за поточну кількість паличок у купці.

2.  Якщо після цього купка стає порожньою, вивести окремим рядком фразу
    "`I won!`" (без лапок, символ-у-символ згідно зразку) і завершити
    роботу.

3.  Інакше, прочитати хід програми-суперниці, тобто кількість паличок,
    які вона зараз забирає з купки (єдине ціле число, в окремому рядку).
    Гарантовано, що хід допустимий (є цілим числом від 1 до 3 і
    не перевищує поточного залишку паличок у купці). Само собою, ця
    гарантія дійсна лише за умови, що Ваша програма правильно визначила,
    що гра ще не закінчилася.

4.  Якщо після цього купка стає порожньою, вивести фразу "`You won...`"
    (без лапок, символ-у-символ згідно зразку) і завершити роботу.

Все вищезгадане повинно повторюватися, докинебудуть забрані всі палички
(тобто, доки якась із програм-гравців не ви́грає). Програма-суперниця
не виводить фраз "`I won!`"/ "`You won...`" чиякихось їх аналогів.

Ця задача є інтерактивною: Ваша програма не отримає всіх вхідних даних
на початку, а отримуватиме по мірі виконання доуточнення, що
залежатимуть від попередніх дій Вашої програми. Тим не менш,

::: slshape
її перевірка буде [автоматичною]{.underline}
:::

. Тому, в цій програмі, як і в програмах--розв'язках інших задач,
тежслід *не* \<\<організовувати діалог інтуїтивно зрозумілим чином\>\>,
а чітко дотримуватися формату. Тільки це не формат вхідного та вихідного
файлів, а формат спілкування з програмою, яка грає роль суперника.

Настійливо рекомендується, щоб Ваша програма після кожного свого
виведення робила дію `flush(output)`(Pascal), вона ж
`cout.flush()`(C++), вона ж `fflush(stdout)`(C), вона ж
`sys.stdout.flush()`(Python), вона ж `System.out.flush()`(Java).
Це істотно зменшує ризик, що проміжна відповідь \<\<застрягне\>\> десь
по дорозі, не дійшовши до програми-суперниці.

::: exampleSimpleThree
5em5em10cmПримітки
:::

У приблизно половині тестів Ваша програма матиме справу з ідеальною
програмою-суперницею, яка не робить помилок. У іншій приблизно
половині--- з різними програмами-суперницями, які грати не вміють---
тобто, роблять лише ходи, які дотримуються формальних вимог \<\<забирати
лише від 1 до 3 паличок\>\> та \<\<забирати не більше паличок, ніж
реально є у купці\>\>, алеможуть вибирати не найкращий з допустимих
ходів, дотримуючись кожна своїх власних уявлень про те, як краще грати в
цю гру. Буде оцінюватися як уміння Вашої програми виграти там, де це
легко, так і вміння Вашої програми достойно, згідно правил гри,
програти, так і вміння Вашої програми скористатися (тежзгідно правил)
помилками чи іншими неадекватностями програми-суперниці, якщо такі
будуть.

За будь-яке порушення правил гри збоку Вашої програми, відповідний тест
оцінюватиметься як не пройдений.
:::
