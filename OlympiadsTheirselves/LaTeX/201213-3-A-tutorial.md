Задачу в принципі можна розв'язувати по-різному, в тому числі й з
використанням циклів, щоб перебирати можливі номер під'їзду й номер
поверху (при ${N\,{\<}\,999}$ це вкладеться в обмеження часу). Алепряма
формула природніша, і, мабуть, простіша, тож зосередимось на ній.

Для мов програмування, де є заокруглення вгору (`ceil`, `Ceiling`,
тощо), можна використати його (разом з діленням у типі з рухомою комою).
Якби був лише один під'їзд, то можна було б казати, що на 1-му поверсі
розміщено квартири з $\,$`<!-- -->`{=html}1 по$\,k$, на 2-му--- з
$\,{(k\,{+}\,1)}$ по$\,{(2\,{\cdot}\,k)}$, тощо; отже, для квартир з
1-го поверху $0\dib{{<}}n/s\dib{{\<}}1$; з2-го,
$1\dib{{<}}n/s\dib{{\<}}2$; і т. д. Звідси, номер поверху можна *було б*
виражати як `(int)(ceil(((double)n)/k))`(C/C++; частину дужок можна і
прибрати; забезпечити, що ділення робиться в типі `double`, можна й
іншими засобами, але якось це зробити треба), чи `ceil(N/k)`(Python3),
тощо. Оскільки під'їзд не завжди один, в точності ця формула
малокорисна, але потрібні можна побудувати аналогічно. Скажімо, з того,
що 1-йпід'їзд містить квартири від 1 до${s\,{\cdot}\,k}$ (включно),
2-й--- від ${s\,{\cdot}\,k\,\,{+}\,1}$ до${2\,{\cdot}\,s\,{\cdot}\,k}$,
і т. д., слідує, що визначити номер під'їзду можна виразом
`(int)(ceil(((double)N)/(s*k)))`(C/C++), чи `ceil(N/(s*k))`(Python3),
тощо. Якщо номер під'їзду вже пораховано і присвоєно у змінну
(наприклад, `p`), можна обчислити \<\<номер квартири у межах
під'їзду\>\> (втих самих межах від 1 до${s\,{\cdot}\,k}$ включно) як
`n`$\,$`-`$\,$`s*k*p`; позначимо цю величину як `n_p`, після чого номер
поверху можна обчислити згідно раніше розглянутих міркувань, як
`(int)(ceil(((double)n_p)/k))`(C/C++), чи `ceil(n_p/k)`(Python3), тощо.

А що робити, якщо писати на Паскалі, де нема заокруглення вгору?
По-перше, якщо доступний PascalABC, там функція `Ceil` *є*; головний
недолік PascalABC (що він помітно повільніший за FreePascal) у цій
задачі абсолютноневажливий. По-друге, ніщонезаважає переписати те саме,
реалізувавши заокруглення вгору самому. Є щонайменше два способи
виразити
$\texttt{ceil}(\frac{a}{b})$:(А) `res:=adiv b;ifamodb then inc(res);`(Б) `(a+b-1)div b`.

[]{#text:about-good-formulae-for-0-based-numbering
label="text:about-good-formulae-for-0-based-numbering"} Варто
відзначити: *якби нумерація квартир, поверхів і під'їздів була не з 1,
аз 0, всі формули були б простіші*. А са́ме: номер під'їзду виражавсяб як
`N/(s*k)` (С-подібними мовами) чи `N//(s*k)`(Python3) чи
`N div (s*k)`(Pascal); номер поверху виражавсяб як `(N/k)%s`
(С-подібними мовами) чи `(N//k)%s`(Python3) чи
`(N div k) mod s`(Pascal). Власне, ці формули настільки простіші, що
може мати смисл навіть перетворити прочитане `N` (зменшившина 1),
провести обчислення за цими формулами, й перетворити кожен з отриманих
результатів, збільшившина 1. (Само собою, перетворенням підлягають лише
*номери* квартири, поверху й під'їзду, нівякомуразі не*кількості*
$s$ та $k$.) А щецепояснює, чому, хоча людям нумерувати з 0 незручно,
більшість сучасних мов програмування мають безальтернативну нумерацію
масивівз 0: таке спрощення перерахунків з'являється не лише в цій
задачі, а й у багатьох схожих (зокрема, при перетворенні індексів
багатовимірного масиву в адресу в пам'яті та зворотньо).
