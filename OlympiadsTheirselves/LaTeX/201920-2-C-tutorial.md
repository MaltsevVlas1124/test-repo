*Деякі* способи їх розв'язувань, справді, майже однакові. Але
\<\<лобовий\>\> спосіб набирає далеконевсібали,асеред ефективніших
способів далеконевсі однаково придатні до обох задач.

І так, і ні.Що ж зробиш, як олімпіади з інформатики (програмування) вже
більше 25 років передбачають розрізнення більш ефективних розв'язків від
менш ефективних,авцих задачах швидкість введення/виведення істотно
впливає на швидкість програми в цілому?.. Це не створено автором задачі
навмисно, це сумний об'єктивний факт, який час від часу проявляється на
оліміпадах (див. також стор. ,--). Іцеточно *не* є істотною складовою
оцінювання: якби хотіли це перевіряти, то інформацію про різні способи
читання не доносили б різними способами безпосередньо на турі, авсіляко
приховували. І якраз приховування було б несправедливим щодо тих
учасників, які взагалі-то придумали й реалізували ефективний алгоритм,
але програма не набирає гідний бал виключно тому́, що повільно читає
вхідні дані. \<\<Просто зменшити вхідні дані та/або збільшити обмеження
часу\>\>--- теж таксобі пропозиція, бо тоді почали б надто легко
проходити не досить ефективні алгоритми.

Приклади нехитрих \<\<лобових\>\> розв'язків можна бачити за посиланнями

::: Huge
::: color
red TODO: add IDEONE links here
:::
:::

. Вони повинні проходити блоки 1--2, але не проходити жодного іншого
блоку. Адже складність $O(M{\cdot}N{\cdot}T)$ (див., зокрема, стор. --)
свідчить про крайню сумнівність вкладання виконання у секунду для
одночасно максимальних $N$, $M$, $T$ будь-якого зблоків3--6.
(\<\<Заперечення\>\> у стилі

::: slshape
\<\<нуне будуть же там геть усі прямокутники-запити вигляду "1 N 1 M",
ботоді взагалі всі суми-відповіді будуть однакові\>\>
:::

нічогісінько не змінює: наприклад, утесті зблоку 3 дуже навіть може
бути, скажімо, 80$\,$% запитів, де $1\,{\<}\,i_1\,{\<}\,5$,
$20\,{\<}\,i_2\,{\<}\,25$, $1\,{\<}\,j_1\,{\<}\,200$,
$1800\,{\<}\,j_2\,{\<}\,2019$, і 20$\,$% випадкових; це не сильно
зменшить час, а однакових відповідей буде мало.)

Якби рахувати треба було один раз (чи двічі, чи навіть 10 разів), це
був би найдоцільніший (бонайприродніший) спосіб. Але ж просять
порахувати $T$разів для (мабуть, різних) прямокутників-запитів.
Найзагальніша ідея обох задачC, D--- придумати, щоб такого зробити з
двовимірним масивом (одним! незмінним!), щоб, хай навіть витративши
(*єдинократно!*) якісь додаткові зусилля/час/пам'ять (це,доречі,
називають *передобробкою*), надалі могти швидше відповідати на самі́
запити.

::: itshape
::: bfseries
Як са́ме робити
:::

передобробку і

::: bfseries
що са́ме
:::

вона

::: bfseries
повинна дати
:::
:::

--- це вже складніше питання; різним варіантам відповіді на нього
присвячена решта розбору цієї задачі та майже весь розбір наступної.

Розглянемо аналогічну (але простішу) задачу, де дано
[*одно*]{.underline}вимірний масив і треба відповідати на багато запитів
*\<\<яка сума всіх підряд елементів з $i$-го по $k$-й?\>\>* (до речі,
така задача вже давно є на , як задача A
[змагання 7](https://ejudge.ckipo.edu.ua/cgi-bin/register?action=212&contest_id=7&locale_id=2)).

Там варто завести масив, кожен елемент якого має смисл *\<\<Яку суму
мають усі елементи від початку до поточного?\>\>*. Чи починати, як у
наведеному прикладі, нумерацію елементів само́го масиву з 1, а масиву
сумз 0--- питання дискусійне, такі деталі можна робити по-різному, в
кожного способу свої переваги й вади; можна у програмі написати якось
інакше, але у поясненнях буде са́ме так.

Маючи такий масив`sum`, можна рахувати суму будь-якого проміжку

::: ttfamily
data\[j\]$\,$+$\,$...$\,$+$\,$
:::

*за одне віднімання*,як

::: ttfamily
sum\[k\]$\,$-$\,$
:::

, адже з \<\<загальної\>\> суми

::: ttfamily
data\[1\]$\,$+$\,$...$\,$+$\,$
:::

якраз приберуть \<\<непотрібну\>\> суму

::: ttfamily
data\[1\]$\,$+$\,$...$\,$+$\,$
:::

.

Що це дає для початкової задачі? Навіть якщо реалізувати *лише* цей
прийом, тобто порахувати префіксні суми для кожного рядка двовимірного
масиву окремо, і відповіді на запити рахувати як \<\<перебрати рядки
прямокутника, й додати в циклі суми, знайдені одним відніманням
кожна\>\>--- навіть тоді виходить $O(N{\cdot}M\,{+}\,T{\cdot}N)$ дій, що
повинно точно проходити блок 3, а при акуратній реалізації цілком може
пройти також блок 5. (Звісно, для цього потрібно правильно рахувати
масив префіксних сум, наприклад, якось у стилі

::: ttfamily
sum\[i\]\[0\]:=0; for j:=1 to Mdo
sum\[i\]\[j\]:=sum\[i\]\[j-1\]+a\[i\]\[j\]
:::

,ні в я́комуразінезапускаючи ще один цикл для кожного елементу префіксних
сум.)

Блок 4 яскраво демонструє, що префіксні суми за рядками й перебір
рядків--- лише часткове покращення, і може підбити до того, щоб рахувати
в одній програмі зразу два варіанти префіксних сум: за рядками і за
стовпчиками. Що ж, якщо правильно вибирати, коли яка сума доцільніша, це
може ще щось покращити: дозволити одній програмі пройти і блок 3,
і блок 4; покращити \<\<запас\>\> часу при проходженні блоку 5 (але якщо
він і так пройшов, то збільшення запасу ніяк не підвищує бали за
задачу). Але само по собі це ще не повинно давати можливість пройти
блок 6 і тим розв'язати задачу повністю. У поєднанні зі ще якимись
оптимізуючими прийомами, це вже можливо; наприклад, можна придумати
такий прийом, як *\<\<зарозмірами прямокутника поточного запиту,
вибрати, який з трьох підходів має бути найшвидшим саме для нього:
порахувати за рядками, чи порахувати за стовпчиками, чи (якщо він займає
майже увесь основний масив) порахувати як різницю суми всього основного
масиву, мінус сума \<\<рамки\>\>, що не потрапляє, а суму \<\<рамки\>\>,
що не потрапляє, порахувати через горизонтальні та вертикальні префіксні
суми\>\>*. Або такий прийом, як *\<\<порахувати усі ці горизонтальні та
вертикальні префіксні суми і длякожного рядка/стовпчика окремо,
і дляшматків по 10 рядків/стовпчиків підряд; це дасть можливість
рахувати за одне віднімання суму не одного рядка/стовпчика, а зразу
десяти (щоправда, якщо ме́жі прямокутника-запиту не потрапили на ці
красиві ме́жі шматків по 10 рядків/стовпчиків підряд, то по краям
(чизодного краю) треба буде пододавати також суми окремих
рядків/стовпчиків)\>\>*. Або ще якийсь оптимізуючий прийом--- їх тут
може бути чимало різних. Але спосіб, наведений у наступному пункті,
і простіший у плані технічної роботи, і переконливіший у плані
теоретичного доведення часу його роботи.

Замість незручно й неефективно працювати з багатьма окремими
одновимірними префіксними сумами, краще здогадатися до такого їх
двовимірного узагальнення: будемо для кожного елементу двовимірного
масиву тримати суму всіх елементів, розміщених лівіше&вище за нього
(конкретно у тому варіанті, який наведено на рисунку праворуч---
включаючи рядок&стовпчик само́го поточного елемента; наприклад,
$\texttt{sum[2][3]}\,{=}17$ виражає суму
${(2\,{+}\,3\,{+}\,4)}\dibbb{{+}}{(3\,{+}\,1\,{+}\,4)}$; але, як і для
одновимірного випадку, можуть бути варіанти, де індекси зсунуті якось
інакше).

Коли такий масив уже побудований, то взнавати потрібну суму для
прямокутника $i_1$ $i_2$ $j_1$ $j_2$ можна виразом

::: ttfamily
sum\[i2\]\[j2\]- sum\[i2\]\[j1-1\]- sum\[i1-1\]\[j2\]+
sum\[i1-1\]\[j1-1\]
:::

.

Аргументація цього частково зображена на рисунку: щоб знайти суму
області, виділеної рамкою, з суми області, виділеної сірим, віднімемо
суму області, виділеної однією штриховкою, та суму області, виділеної
іншою штриховкою; область, де штриховки накладаються, один раз додана й
двічі віднята, тож, щоб це компенсувати, треба додати її.

Будувати цей масив `sum` можна за правилом

::: ttfamily
sum\[i\]\[j\]= sum\[i\]\[j-1\]+ sum\[i-1\]\[j\]- sum\[i-1\]\[j-1\]+
a\[i\]\[j\]
:::

, яке обґрунтовується майже так само, тільки сіра незаштрихована область
має складатися з єдиного елемента.

Тобто, заповнити масив `sum` можна за $\Theta(1)$ дій на кожен елемент,
а відповідати на запити можна за $\Theta(1)$ дій на кожен запит. Читання
вхідних даних та виведення результатів мають аналогічні оцінки часу.
Таким чином, весь алгоритм має складність ${\Theta(N{\cdot}M+T)}$.
(Доречі, якраз поєднання \<\<час роботи пропорційний розміру вхідних
даних\>\> та \<\<вхідні дані величезні\>\> пояснює, чому в цій задачі аж
так важливі швидкі введення/виведення: вони не \<\<губляться\>\> за
рештою операцій.)

Якщо писати мовою програмування, в якій розмір масиву задається зарані
(під час написання програми, отже, до прочитання вхідних даних)--- так,
тоді це єдиний вихід. Але ліміту пам'яті на це вистачає, із запасом.
А якщо задавати розміри масивів після прочитання вхідних даних, таке
питання, зазвичай, взагалі не виникає: прочитали $N$, $M$, задали
розміри...; івційзадачі [*не*]{.underline} виникає рідкісної ситуації,
коли заміна динамічної пам'яті на статичну дає істотне прискорення.

Не те, щоб гетьне можна; частина способів, описаних у наступній задачі,
цілком годяться, щоб пройти у цій задачі, наприклад, блоки1--5. Є й інші
способи, геть невеликі модифікації яких повністю вирішують зразу обидві
задачі. Але вони складніші за згадані тут. Тому́, автор більш схиляється
до того, що, мабуть, легше написати окремо спосіб для цієї задачі, якось
оснований на префіксних сумах, і окремо інший спосіб для наступної
задачі; але це сильно залежить від того, які са́ме ідеї вдалося пригадати
чи придумати під час туру.

З точки зору переважної більшості алгоритмів, нічим: майже будь-яка
розумно написана програма, що проходить 1-йблок і не містить явних
обмежень проти 2-гоблоку, має проходити такожі2-й. Але відмінність може
проявитися для помилкових реалізацій, які: неправильно читають
багатоцифрові чи́сла; неправильно обробляють ситуацію, коли є лише один
стовпчик чи лише один рядок; намагаються використати аж надто короткий
тип даних (тут, зокрема, для когось може виявитися несподіванкою, що у
FreePascal тип `integer` досі 16-бітовий, тому треба використовувати для
самих елементів щонайменше `longint`, для сум `QWord` чи `int64`;
див.також стор.  та стор. ); якось дуууже вже неефективно читають вхідні
дані. Що ж, ситуації, коли програмі (нехай навіть мовою Python)
не вистачає 2 секунд на тому тесті, на якому найкраща наявна програма
мовою C++ вкладається у 0,001 с (різниця у тисячі разів), все-таки є
явною ознакою погано написаної програми...
