Тут треба акуратно писати досить велику, як для IIетапу, програму,
поєднуючи різні стандартні алгоритми. Але, не зважаючи на страшну назву
\<\<ко-анаграмічно\>\> та інші громіздкості, тут недуже-то й треба
самому придумувати щось математичне. Якщо, звісно:

-   знати стандартний алгоритм перевірки простоти числа́;

-   вміти *або перевіряти, чи*чи́сла складаються з одних і тих са́мих
    цифр, *або генерувати перестановки* послідовностіцифр.

Cтандартний алгоритм перевірки простоти числа́ $n$ (при${n\,{\>}\,2}$)---
пробувати ділити його на,,..., `round`$(\sqrt{n})$, іякщо хоч раз
поділилося без остачі--- число скла́дене, якщо ні разу--- просте. Важливо
перевіряти докореня (анедо$n$ чи$n/2$), бо це значно менше (див.також
стор. ).

Перевіряти, чи чи́сла складаються з одних і тих самих цифр у різному
порядку, можна по-різному. Один з простих і зручних підходів---
відсортувати (наприклад, занеспаданням) цифри окремо одного з них,
окремо іншого, й порівняти отримані відсортовані послідовності (вони
рівні тоді й тільки тоді, коли чи́сла складаються з одних і тих самих
цифр). Оскільки кількість цифр дуже маленька, нема смислу
використовувати quickSort чи подібні ефективні алгоритми сортування,
доречнішим буде сортування вставками чи навіть бульбашкове.

Таким чином, схема алгоритму може бути приблизно такою. Функція
(підпрограма) \<\<перевірити, чи є число ко-анаграмічно-простим\>\> має
вигляд:

1.  Створити копію цього числа́-аргумента у рядковому (`string`-овому)
    вигляді;

2.  Відсортувати цифри (символи рядка) за неспаданням;

3.  Перебрати усі числа з відповідною кількістю цифр, від 0...01 до
    9...99, і для кожного з них:

    1.  перетворити у рядок (знову як копію, щоб не псувати оригінал);

    2.  теж відсортувати цифри числа́ за неспаданням;

    3.  []{#item:201415-2-d-both-tests
        label="item:201415-2-d-both-tests"} якщо відсортовані
        послідовності виявилися різними --- значить, поточне число не є
        перестановкою цифр досліджуваного числа́ і його слід пропустити,
        а якщо однаковими --- запустити перевірку поточного числа́ на
        простоту.

    Якщо перевірка у
    п. [\[item:201415-2-d-both-tests\]](#item:201415-2-d-both-tests){reference-type="ref"
    reference="item:201415-2-d-both-tests"} хоча б один раз виявила, що
    число просте--- функція в цілому має повернути результат \<\<число є
    ко-анаграмічно-простим\>\>. Якщо жодного разу не виявила---
    результат \<\<не є\>\>.

Тепер лишається тільки перевіряти, чиє ко-анаграмічно-простим саме́
введене число $n$, потім ${n\,{+}\,1}$, ${n\,{+}\,2}$, ... Приклад
реалізації--- .

Для цієї реалізації дуже складно івивести асимптотичну оцінку часу
роботи, івикористати цю асимптотику для оцінювання конкретного часу
роботи вмілісекундах. Наприклад, зовсім неясно, як оцінити кількість
ітерацій самого зовнішнього циклу (скільки чисел $n$, ${n\,{+}\,1}$, ...
треба перебрати, щоб гарантовано знайти ко-анаграмічно-просте).
Уперевірці простоти́, хоч і видно верхню межу циклу `round(sqrt(n))`, але
ж розумна реалізація обриває цикл після першого знайденого дільника, і
середня кількість ітерацій виявляється меншою (анаскільки--- неясно); і
так далі.

Програма може працювати швидше, якщо, замість перебору всіх чисел з
відповідною кількістю цифр (від 0...01 до 9...99), відразу генерувати
лише ті, що складаються з потрібного набору цифр. При обмеженні
${n\,{\<}\,9999}$ це неважливо, тож не будемо описувати, як робити це
вручну (охочі можуть знайти в літературі чи Інтернеті за назвою
*генерація перестановок*, англ. *generate permutations*). УмовіC++ така
генерація є готова (функція `next_permutation` бібліотеки `algorithm`).
