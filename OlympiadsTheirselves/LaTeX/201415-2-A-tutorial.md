Оскільки розміри малі (кількість цифр$\dib{{\<}}$`<!-- -->`{=html}5,
видаляється одна), можна просто перебрати всі варіанти викреслення
однієї цифри (усе число без1-ої, усе без2-ої, тощо), і вибрати з них
максимальний. Зручно (хоча й не обов'язково) перевести число урядок
(`string`), і вилучати символи урядковому поданні. Реалізацію див. . При
бажанні, її можна спростити, роблячи все виключно рядками. (Взагалі
буває проблема \<\<у числах ${7{<}10}$, аурядках
`"7"`$\dib{{>}}$`"10"`\>\>, але *тут* вона не проявиться, бо кількості
цифр усіх потрібних чисел однакові.)

Якщо мати лише мету розв'язати цю задачу при цих обмеженнях--- краще
обмежитися першим правильним способом і нечитати далі. Аякщо мати
бажання щераз розглянути, як можна доводити правильність алгоритма
(див.також стор. )--- тоді подальший текст важливий.

Ще є правильний розв'язок *\<\<Знайти найлівіше місце, де зразу після
меншої цифри йде більша, і викреслити меншу са́ме зцих двох; якщо жодного
такого місця нема (наприклад, учислі) --- викреслити останню цифру\>\>*.

[]{#text:proof-max-num-by-strike-out-one-digit
label="text:proof-max-num-by-strike-out-one-digit"} Занумеруємо цифри
початкового числа́ зліва направо $\overline{a_1a_2\dots{}a_n}$.
Розглянемо спочатку випадок \<\<нема жодного місця, щоб після меншої
цифри йшла більша\>\>, тобто
$a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$. Згідно алгоритму, треба
викреслити $a_n$, лишивши $\overline{a_1a_2\dots{}a_{n-1}}$. Якщо
всупереч алгоритму викреслити деяку $a_j$ ($1{\<}j{<}n$), вийде
$\overline{a_1a_2\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$. Початок
$\overline{a_1a_2\dots{}a_{j-1}}$ спільний, тож результат порівняння
визначається частиною, де
$a_{j+1}$замість$a_j$,$a_{j+2}$замість$a_{j+1}$,
...,$a_{n}$замість$a_{n-1}$. Оскільки розглядаємо ситуацію
$a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_n$, то або
${a_j{>}a_{j+1}}$, або ${a_j{=}a_{j+1}}$. При $a_j\dib{{>}}a_{j+1}$,
число, отримане всупереч алгоритму, менше (гірше) отриманого згідно з
алгоритмом, бо після спільного початку йде $a_{j+1}\dib{{<}}a_j$. Якщо ж
$a_j\dib{{=}}a_{j+1}$, то можна приєднати цю цифру до спільного початку
і повторити *всі* міркування для \<\<$a_{j+2}$замість$a_{j+1}$\>\>.
Ітакдалі. Кінець кінцем, або десь отримаємо, що число всупереч алгоритму
менше (гірше) числа́ згідно з алгоритмом, або дійдемо до
$a_j\dib{{=}}a_{j+1}\dib{{=}}\dots\dib{{=}}a_n$, тобто викреслення $a_j$
призводить до *того ж* результату, що алгоритм.

Лишилося розглянути випадок, коли місце, де$a_i{<}a_{i+1}$, існує. Нехай
$i^{\star}$--- найлівіша з таких позицій, тобто
$a_1\dib{{\>}}a_2\dib{{\>}}\dots\dib{{\>}}a_{i^{\star}}$ і
$(a_{i^{\star}}{<}a_{i^{\star}+1})$. Невигідність видаляти
замість $a_{i^{\star}}$ деяку $a_j$ при $1{\<}j{<}i^{\star}$ доводиться
аналогічно попередньому абзацу. Лишилося довести невигідність видаляти
$a_j$ при $i^{\star}{<}j{\<}n$, а це зовсім легко: згідно з алгоритмом
отримуємо
$\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}+1}\dots{}a_{n}}$,
всупереч---
$\overline{a_1a_2\dots{}a_{i^{\star}-1}a_{i^{\star}}\dots{}a_{j-1}a_{j+1}\dots{}a_{n}}$,
тобто початок $\overline{a_1a_2\dots{}a_{i^{\star}-1}}$ спільний, потім
${a_{i^{\star}+1} > a_{i^{\star}}}$. Розглянуті випадки покрили всі
можливі ситуації, доведення успішно завершене.

Чи має дру́гий алгоритм переваги над першим? При ${n{\<}99999}$--- ні.
*Якби* чи́сла були значно більшими (наприклад, до мільйона цифр;
не \<\<$n{\<}10^6$\>\>, аякби *кількість цифр* могла сягати мільйона)---
тоді виявилосяб, що перший алгоритм правильний, але повільний, а дру́гий
правильний і ефективний. Асимптотичні оцінки: $\Theta(L^2)$ для першого,
$\Theta(L)$ для дру́гого, де $L$--- кількість цифр.
