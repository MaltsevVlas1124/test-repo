Для пошуку першого рядка відповіді слід реалізувати код, що знаходить
номер купе за номером місця, й порівняти результати для двох введених
місць. Можна, наприклад, поділити (дробово) на 4, потім заокруглити
вгору (мовами C/C++, `(int)(ceil(p/4.0))`). Мовами, де стандартного
аналога `ceil` нема, це можна виразити, наприклад, формулою
`(p+3) div 4`, де `div`--- цілочисельне ділення. Див.також стор. .

Очевидно, місця́ з непарними номерами нижні, азпа́рними верхні, тобто при
`p%2==0` (на Pascal, `p mod 2=0`) `HIGH`, інакше `LOW`. Єйінші способи
перевірки парності, як-то функція `odd(p)` (Pascal) чи порівняння
`(p&1)==1` (C/C++/Java/C#/Python), воно ж `(p and 1)=1` (Pascal), що
дають `true` при [*не*]{.underline}парному `p`; це працює, спираючись на
т. зв.*побітовий`and`*, деталі знайдіть самостійно).

Складність усього разом узятого алгоритму очевидно $\Theta(1)$.

У визначення номера купе і виведення `LOW`/`HIGH` оформлені як
підпрограми. Цене обов'язково, але дозволяє уникнути деяких прикрих
помилок, як-то \<\<помили́вся у формулі визначення номера купе, скопіював
неправильну, потім для одного з місць виправив, а для іншого забув\>\>.
Тому, винесення таких дій у підпрограми вважається правильним стилем і
прикладом т. зв.\<\<повторного використання коду\>\> (code reusing).
