Нехай укупці одна, дві або три палички. Тоді за один хід можна забрати
їх усі й цим виграти. Від суперника тут нічого не залежить.

Тепер нехай укупці чотири палички. Тоді після будь-якого допустимого
правилами гри ходу супернику залишиться або
4$\,$--$\,$`<!-- -->`{=html}1$\,$=$\,$`<!-- -->`{=html}3 палички, або
4$\,$--$\,$`<!-- -->`{=html}2$\,$=$\,$`<!-- -->`{=html}2, або
4$\,$--$\,$`<!-- -->`{=html}3$\,$=$\,$`<!-- -->`{=html}1. Після чого,
суперник зможе взяти усі палички одним ходом і тим виграти.
Ми(1-йгравець) не можемо цьому перешкодити.

Таким чином, позиції \<\<1 паличка\>\>, \<\<2 палички\>\> та
\<\<3 палички\>\> *виграшні*: починаючи з них, можна виграти, і суперник
з цим нічого не вдіє. Апозиція \<\<4 палички\>\> *програшна*: якщо
суперник вміє грати, він точно виграє, і той, кому дісталося 4 палички,
з цим нічого не вдіє.

Якщо у купці 5, 6 або 7 паличок, можна зробити такий хід, щоб після
нього супернику дісталася купка з 4-хпаличок (що,як ми вжезнаємо,
означає, що він нічого не зможе протиставити правильній грі свого
суперника, тобто нашій правильній грі). Таким чином, позиції
\<\<5 паличок\>\>, \<\<6 паличок\>\> та \<\<7 паличок\>\> теж виграшні.
Аналогічно показується, що позиція \<\<8 паличок\>\> програшна. І так
далі: позиції, де кількість паличок кратна 4, програшні (починаючи з
них, перемогти грамотного суперника неможливо), апозиції, де кількість
паличок не кратна 4, виграшні (треба забирати `n mod 4` паличок, і цим
або виграємо негайно (при${1\,{\<}\,n\,{\<}\,3}$), або супернику
дістанеться програшна позиція).

Аналіз гри часто цим і закінчують, а питання \<\<щоробити, коли нам
дісталася програшна позиція?\>\> або ігнорують, або відповідають на
нього абияк. Зокрема, часто заявляють \<\<разприході зпрограшної
гарантовано виграти неможливо, будемо відтягувати кінець, беручи щоразу
лише по одній паличці: чим довше триватиме гра, тим більше шансів, що
неідеальний суперник помилиться \>\>.

Алев умові не дарма сказано, що уприблизно половині тестів треба грати
проти безграмотних програм-суперниць, *причому в різних тестах різних*.
Серед цих безграмотних програм-суперниць є така, яка завжди намагається
забирати якнайбільше паличок, тобто або 3, або, якщо їх всього лишилося
менш, ніж 3, то всі. Правда, у*такої* суперниці можна виграти, маючи
на початку програшну позицію? Але для цього треба, перебуваючи у
програшній позиції, взяти не одну паличку, а 2або 3... (Це не допомагає,
якщо початкова кількість паличок$\,$=$\,$`<!-- -->`{=html}4:
програма-суперниця \<\<не встигає збитися\>\>; але при значно більших
початкових кількостях паличок \<\<перехоплення ініціативи\>\> цілком
реальне.)

Таксамо, як не можна упрограшних позиціях завжди виводити 1, не можна й
виводити завжди 2 чи завжди 3, бо серед інших програм-суперниць є та, що
завжди намагається забирати дві палички (й тільки якщо лишилася всього
одна, то забере її одну), а також та, що абсолютно завжди забирає одну
паличку. Тому треба або робити хід із програшної позиції якимсь хитро
залежним від того, з якої са́ме програшної позиції ходимо...

[]{#text:random-in-simple-sticks-game
label="text:random-in-simple-sticks-game"}...або застосувати всемогутні
випадкові чи́сла: звиграшних позицій ходити, згідно з основним аналізом,
ходом `n mod 4`, азпрограшних--- суто випадково, від 1 до 3. Це,звісно,
не допоможе проти грамотного суперника, але ситуації, описані у двох
попередніх абзацах, стануть неможливими, й увипадках, децеможливо,
ініціатива перехоплюватиметься. (Ще раз: тут *не* пропонується *завжди*
ходити випадково; така програма майже завжди програвала б
\<\<ідеальному\>\> супернику, котрий не помиляється. Пропонується
у першу чергу дивитися на виграшність/програшність, авжеувипадку
програшності, коли гарантій всеодно нема, ходити випадково.)

Урозв'язках цієї задачі якось трапилася кумедна помилка. Одна особа,
бажаючи зробити чи́сла якнайвипадковішими, писала перед кожним викликом
`(rand()%3)+1` (згенерувати чергове псевдовипадкове число від 1 до 3)
новий виклик `srand(time(NULL))` (переналаштувати генератор
псевдовипадкових чисел). Така реалізація (мовою C++) програє́ згаданим
суперникам вигляду \<\<намагатися завжди бра́ти ...\>\>, причому при
різних запусках--- різним суперникам (нарізних тестах): то супернику,
що намагається завжди бра́ти 3, то тому, що намагається завжди бра́ти 2,
то тому, що завжди бере 1. Причина в тому, що `time(NULL)` залежить від
поточного системного часу, але не наносекунд, які щоразу різні, а цілих
секунд, які, як правило, однакові протягом усього виконання програми.
Так і виходило, що генератор, щоразу однаково переініціалізований,
видавав одне й те ж.[]{#text:sticks-simple-end
label="text:sticks-simple-end"}

Розглянута в цій задачі гра має назву: *граБаше́*. Втім, цю задачу
потроху розв'язували різні люди, внесок К.$\,$Г. Баше не є вирішальним,
і назва \<\<граБаше\>\> поширена, але не  загальноприйнята.
