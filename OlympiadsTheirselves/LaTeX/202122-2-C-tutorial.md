Можна підтримувати лічильник, який в момент початку обробки рядка
рівний 0, прикожній "`(`" збільшується на 1, априкожній "`)`"
зменшується на 1. Рядок правильний тоді й тільки тоді, коли виконуються
обидві властивості: (1) наприкінці обробки всього рядка цей лічильник
знову рівний 0; (2) за весь час обробки рядка лічильник ні разу
не ставав строго від'ємним.

Щоб пройти частину `C2`, важливо не тримати в пам'яті одночасно весь
рядок, а читати його символ за символом, і, обробивши поточний символ,
тут же його забувати. Перевірено (щедоофіційного туру), що всіма мовами,
оголошеними в пам'ятці як гарантовані (`g++`, `fpc`, `python3`, `java`)
це написати можливо. Щоправда, для `python3` для цього довелося
додатково збільшити ліміт пам'яті та ліміт часу (й на турі перевірка
відбувалася на вже збільшених; суть у тому, що не було спроб учасників
читати по одному символу...); також, для `python3` не вдалося написати
код так, щоб один і тойса́мий код проходив хоч `C1`, хоч `C2` (цейбуло
однією з причин розділення однієї задачі `C` натехнічно різні частини
`C1` та `C2` в єджаджі).

Досить природнім є також також розв'язок

::: slshape
\<\<поки можливо, видаляти всі входження `“()”`; початковий рядок був
правильним тоді й тільки тоді, коли такі видалення закінчуються порожнім
рядком\>\>
:::

. Він повільніший за вищезгаданий, особливо на вхідних даних, де велика
вкладеність дужок. Початковим наміром було, щоб цей розв'язок набирав
десь 120--140 балівзі 180. Однак, через недогляд автора задачі, цей
розв'язок міг набирати чи не набирати повний бал складової `C1`
(180 балів), залежно від того, наскільки ефективно реалізована заміна
підрядка у відповідному бібліотечному методі, через що виникла ситуація,
що коли мова програмування забезпечує більш ефективну заміну підрядків,
то цей алгоритм проходить усі тести частини `C1`, аколименш ефективно,
то не всі. Оскільки це з'ясувалося лише після того, як дехто з учасників
отримав повний бал за такий розв'язок, було прийнято рішення так і
залишити, бо інакше це було б відбирання вже виставлених балів, що украй
небажано.

Якщо дуже уважно прочитати умову, можна побачити, що в `C2` заборонено
порожній рядок (жодного символа), а в `C1` він не заборонений (отже,
дозволений) і формально задовольняє вимогам правильності; тобто, треба
вміти обробляти ситуацію, коли серед рядків є порожній (щоєпроблемою,
зокрема, якщо писати мовоюC++ і читати оператором "`>>`"), і виводити
для порожніх рядків відповідь `1`.
