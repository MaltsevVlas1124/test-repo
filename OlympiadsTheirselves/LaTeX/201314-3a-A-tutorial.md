Впринципі, *можна* вивести аналітичну формулу, алецепотребу́є знань
зтеорії чисел (охочі можуть знайти, що таке *кільце залишків за модулем*
та *мала́ теорема Ферма*, і застосувати до цієї задачі). Всеце було*би*
доцільним, *якби* довжина ISBN-коду становила, наприклад, сотнітисяч,
так що розглянутий далі простіший і значно більш \<\<програмістський\>\>
(ане\<\<математичний\>\>) підхід працював*би* надто довго.

Адля 10 цифр підходить і значно простіший перебір, тобто перепробувати
усі варіанти від 0до 9 і для кожного подивитися, чивиконується описана
вумові правильністьISBN. Приклад реалізації див.. Правда, при різних
правильних відповідях ця програма вивела б усі, хоча на олімпіадах треба
виводити будь-яку одну. Насправді це неактуально, бо різні правильні
відповіді неможливі (хто вивчав питання, згадані у попередньому абзаці,
можуть це довести; решта можуть абоповірити, абодописати у розв'язок
`break` для обривання циклу після виведення першої відповіді.)

Говорити про асимптотичну складність некоректно, бо нема того розміру
вхідних даних, який міг би прямувати до $\infty$. *Якби* довжина
ISBN-коду становила довільне$N$ (але таке, щоб $N{+}1$ було простим,
іщоб аналогічна сума добутків ділилася без остачі на$N{+}1$), можна
було *би* сказати, що перебір має складність$\Theta(N^2)$,
атеоретико-числовий розв'язок---
${\Theta(N+\log{}N)}\dib{{=}}{\Theta(N)}$.

Ще *може* бути проблемою формат вхідних даних, особливо для
малодосвідчених користувачів С++: `cin>>a>>b` ніби читає в `a` те, що до
пропуску, й у `b` те, що після; алев*обох* випадках \<\<пробіл замінює
найпершу цифру\>\> та \<\<... найостаннішу ...\>\> всіосмислених цифр
ідуть в `a`. Може спа́сти на думку читати у циклі окремі `char`-и; але
при стандартних налаштуваннях `cin>>c` (`c` ---типу`char`) взагалі
пропускає пропуски, і взнати його позицію неможливо. Один зі способів
вирішення цієї проблеми--- перед читанням `char`-ів викликати
`cin.unsetf(ios::skipws)`, щоб пропуски та переведення рядка таки
читались у ті `char`-и. Інший--- використати функцію `getline(cin,s)`
(`s` ---типу`string`); вона (які`readln` мови Pascal) читає все,
включаючи пробіли, до кінця рядка.
