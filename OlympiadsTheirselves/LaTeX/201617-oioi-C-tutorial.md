Перш за все, рекомендуємо перечитати все, що сказано на стор.  про те,
як неправильні розв'язки інтерактивних задач провокують вердикт "Wall
Time Limit Exceeded". Переходячи ж до суті конкретно цієї задачі,
наведена у прикладі \<\<стратегія\>\> фактично такою не є. Хочзаїї
допомогою і зручно вгадати 17, але як щодо 91? А щодо 987987981?

Насправді це широковідома класична задача, яку слід розв'язувати так
званим *бінарним пошуком* (він же*бінпошук*, він же*двійковий пошук*,
він же*дихотомія*). Коротко суть описана на стор. , детальніше
рекомендуємо знайти вІнтернеті або літературі. До речі, на цьому ж сайті
`ejudge.ckipo.edu.ua` є змагання 53 \<\<Дорішування теми "Бiнарний та
тернарний пошуки" Школи Бобра (23.10.2016)\>\>, вякому є ітеоретичні
матеріали, ікомплект задач.

Так що наведемо, без детальних пояснень, посилання на готовий розв'язок
та зауваження щодо деяких тонкостей.

Нехай ме́жі проміжку називаються `left` та `right`. Єдва поширені способи
вибирати середи́ну проміжку`mid`: (1) `mid := (left+right) div 2`;
(2) `mid := left + (right-left) div 2`. Для знакових `left`та`right`,
[*кожен*]{.underline} з них може призвести до переповнень (див.також
стор. ). Тільки `(left + right) div 2` переповнюється тоді, коли обидва
значення `left`та`right` дуже великі за модулем і одного знаку,
а`left +``(right - left) div 2`--- коли `left` дуже велике за модулем
від'ємне, а `right` дуже велике
додатнє.[]{#text:binsearch-fails-examples
label="text:binsearch-fails-examples"} Такщотреба або рахувати у ширшому
типі, або робити розгалуження, щоб вибрати ту з формул, яка краща для
поточних значень `left` та `right`.

Ще один тонкий момент--- уникнути зациклювань. Вони можливі, зокрема
(але не тільки) якщо при отриманні від суперника вердикту "`+`" робиться
присвоєння `left:=mid`. Такий алгоритм успішно звужує проміжок від
величезного до невеликого, але при, наприклад,
$\texttt{left}\dib{{=}}3$, $\texttt{right}\dib{{=}}4$ і загаданому
числі 4 одні й ті самі присвоєння
`mid := (left+right) div 2`${}\dib{{=}}{{(3+4)\bdiv2}{=}3}$,
`left:=mid`${}{=}3$ повторюватимуться вічно (ну, або доки програму
не завершать за те, що вона за 50 запитів так і не добилася
вердикту "`=`"). Конкретно для цієї задачі зручно гарантовано позбутися
зациклювань за рахунок того, що при вердикті "`+`" робити `left:=mid+1`,
а при "`-`" робити `right:=mid-1`. Тобто, зменшувати проміжок одночасно
і за рахунок присвоєння межі значення середи́ни, і за рахунок виключення
само́ї цієї середи́ни, яка теж не є шуканою відповіддю (бо не отримала
вердикту "`=`"). Але, на жаль, при багатьох інших застосуваннях
бінпошуку така ідея просто неправильна.

Ще одна тонкість --- якщо сума `left+right` одночасно і непарна,
і від'ємна, вищезгадані формули `mid := (left+right) div 2` та
`mid := left +``(right-left) div 2` не взаємозамінні навіть при
відсутності переповнень. Перша з них заокруглює до нуля, дру́га---
у менший бік. Зокрема, якщо при вердикті "`+`" робити `left:=mid+1`,
а при "`-`" робити `right:=mid` (без \<\<--1\>\>), то перша з них може
зациклити алгоритм, а дру́га не містить такого ризику.
