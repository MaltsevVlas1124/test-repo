З\<\<при сповзанні кубики ніколинелетять, перекидаючись\>\> *випливає*,
що вони лише зміщуються на правіші позиції, тобто ніякий кубик неміняє
своєї висоти. Кубикам, що лежать надні, сповзати нема куди
(з${1\,{\<}\,a_j}$ слідує, що увесь нижній ряд зайнятий). Будь-який
інший кубик напочатку лежав нанижчому, аневисів уповітрі; отіпринахилі
він або сповзає разом із нижчим, наякому лежить, або, якщо той нижчий
впирається у правого сусіда, асам поточнийні, то поточний зсувається
праворуч, на нового нижчого, теж не змінюючи своєї висоти. (Ситуація, що
поточний впирається у правого сусіда, анижчийні, неможлива, бо для цього
треба, щоб кубик праворуч до того вже висів уповітрі, що неможливо.)

Звідси, для простого часткового випадку, коли стовпчиків лише два і
${a_1\,{>}\,a_2}$ (напочатку 1-й стовпчик був вищим за 2-й), верхні
${a_1\,{-}\,a_2}$ кубиків сповзають з1-го на2-й, післячого вже 1-й
стовпчик виявляється нижчим (*тієї ж* висоти́ $a_2$, якої раніше був2-й),
а2-й вищим (висоти́ $a_1$). Якщо ж напочатку ${a_1\,{\<}\,a_2}$, взагалі
нічого не змінюється. В обох випадках, *перший рядок відповіді являє
собою відсортовану послідовність висот зі вхідних даних*.

Якщо стовпчиків недва, абільше, то всеодно кубики або нерухаються
відносно дна, абозсуваються послідовно на наразі сусідній стовпчик
(можливо, багатократно, але кожен з цих багатьох разів--- насусідній),
і завжди призводить до того, що в кожній парі сусідніх стовпчиків висо́ти
чито лишаються які були, чито обмінюються місцями (більша йде праворуч,
менша ліворуч). Такщо всі сповзання разом узяті, хоч і можуть
відбуватися віншому порядку, ніж сортування, врезультаті дають
відсортовану послідовність висот.

Отже, 1-й рядок відповіді зручно отримати, не моделюючи весь процес
сповзань, а застосувавши ефективний алгоритм сортування (див. далі).

Щоб не плутати вже відсортовану (для 1-ї відповіді) послідовність висот
із початковою, будемо в цьому тексті називати відсортовану послідовність
$h_1$, $h_2$,...,$h_N$ (хоча технічно це той самий масив у різні моменти
часу). Усі рядки з$\,$`<!-- -->`{=html}1 по$\,h_1$ заповнені повністю
(бо$h_1$--- *мімінальна* зусіх висот), тобто можна вивести у 2-й рядок
відповіді $h_1$штук значень $N$ (де $N$--- загальна кількість
стовпчиків). Потім ${h_2\,{-}\,h_1}$ рядків містять ${N\,{-}\,1}$
кубиків, причому це так іпри ${h_2\,{>}\,h_1}$ (тоді у кожному з рядків
від $\,{(h_1\,{+}\,1)}$ до $\,h_2$ включно після зсувів рівно один
крайній лівий стовпчик вільний, арешта зайняті, бо рівно один крайній
лівий стовпчик має строго меншу висоту, арешта більшу-або-рівну), іпри
${h_2\,{=}\,h_1}$ (тоді у відповідь не потрапляє жодне
значення${N\,{-}\,1}$, іце тежправильно, бо тоді на всіх висотах
по$h_1$включно по$N$кубиків, апочинаючи з висоти́${h_1\,{+}\,1}$ строго
менше ніж ${N\,{-}\,1}$ кубик). Аналогічне міркування можна повторити
багатократно й отримати, що далі є рівно${h_3\,{-}\,h_2}$ значень
${N\,{-}\,2}$, рівно${h_4\,{-}\,h_3}$ значень ${N\,{-}\,3}$,...,
рівно${h_{N}\,{-}\,h_{N-1}}$ значень 1.

визначається, в основному, використаним сортуванням. Бульбашка, вибір та
інші прості методи сортування мають складність $O(N^2)$ і не мають
шансів укластися в обмеження часу на всіх тестах. Сортування злиттям,
сортування Хоара (QuickSort) та пірамідальне сортування мають складність
$\Theta(N\log N)$ що при ${N\,{\<}\,123456}$ цілком прийнятно. (Хто
не знає цих алгоритмів--- знайдіть у літературі або в Інтернеті;
сортування Хоара, хоч і називається QuickSort, насправді має складність
$\Theta(N\log N)$ не завжди, а тільки у більшості випадків, іноді
погіршуючись аждо$N^2$; цязадача не містить спеціальних
анти-quicksort-івських тестів, тому са́ме тут це не важливо, але для
розуміння загальної картини варто це знати.)

Можна й скористатися бібліотечним сортуванням, якщо такеє (функція
`sort` бібліотеки `algorithm` мови C++, або метод `Arrays.sort` мови
Java, або метод `sort` пітонівського `list`-а, тощо), не розбираючись,
як це влаштовано всере́дині. Так робити не заборонено. Інша справа, що
знання про те, як насправді влаштовані ці підпрограми, можуть
знадобитися в якихось інших ситуаціях.

В цій задачі можна застосувати *сортування підрахунком* (*counting
sort*). Його суть така: заводиться масив`num`, *індекси* якого
відповідають *висо́там*, а значення--- *кількості* стовпчиків відповідної
висоти́ (технічно--- усі елементи ініціалізуються нулями, а при читанні
вхідних даних, замість`read(a[i])`, робляться дії
`read(a); num[a]:=num[a]+1`).

1-авідповідь (саме сортування підрахунком) формується як
\<\<`num[1]`штук одиниць, потім `num[2]`штук двійок, тощо\>\> (доречі,
це дещо схоже на формування 2-горядка відповіді раніше розглянутим
способом, такщо знання сортування підрахунком може бути корисним як для
того, щоб використати його тут, так і для придумування вищезгаданого
знаходження 2-ївідповіді 1-мспособом).

А2-увідповідь можна отримати так: сформувати наоснові масиву`num`
масив`num_gr_eq`, тобто \<\<кількість більших-або-рівних\>\> (наприклад,
способом, показаним укоді праворуч), і просто вивести усі елементи
`num_gr_eq` читодокінця, читодоки вони ненульові́.

Легко бачити, що асимптотика такого підходу
${\Theta(N\,{+}\,\max a_j)}$, що формально краще за $\Theta(N\log N)$.
Втім, на практиці різниця між ними невелика й у значній мірі нівелюється
часом читання вхідних даних. Такщо питання більше в тому, щозручніше
писати. Якщо є зручне готове бібліотечне сортування--- мабуть, краще
використати його і знаходження 2-ї відповіді через 1-у.
