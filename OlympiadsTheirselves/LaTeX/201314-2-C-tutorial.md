Задачу можна розв'язати ручним аналізом випадків, але це сумнівний
спосіб, доречний, лише коли нема кращих ідей. Запосиланням можна
побачити трохи модифікований варіант програми, яку здав один зучасників.
Він набирає 270балів з, що зодного боку немало, алезіншого--- нааналіз
випадків явно пішло багато часу, бали всеодно неповні, ашукати помилку
в*такому* нагромадженні--- невдячна
справа.[]{#text:about-complicated-code-with-many-ifs
label="text:about-complicated-code-with-many-ifs"}

Щоб уникнути такої ситуації, краще реалізувати осмислений алгоритм, який
обробляє різні вхідні дані більш-менш однотипно.

Раз йдеться промінімальні (закількістю переходів) шляхи, природним є
*пошукушир* (вінже *пошук у ширину*, англ.*breadth first search*,
*BFS*). ЗастосуватиBFS треба донеорієнтованого графа, вершини якого---
вершини куба зі значенням 1 (пояким можна проходити), ре́бра--- ті ре́бра
куба, щопоєднують такі вершини. Причому, раз питають неві́дстань (число),
ашлях (послідовність вершин), потрібен варіантBFS,уякому запам'ятовують
вершини-попередники та роблять відновлення шляху *зворотнім ходом*.
Деталі знайдіть улітературі або Інтернеті.

Інший можливий спосіб--- перебір (наприклад, рекурсивний) усіх можливих
шляхів, що немістять повторень вершин. Приклад такого розв'язку--- .
Детальніше про це можна прочитати вІнтернеті або літературі за назвами
*пошук зповерненнями*, *бектрекінг* (рос.*поиск свозвратом*,
англ.*back-tracking*). Взагалі кажучи, цим недуже складним способом
теоретично можна розв'язати дуже багато задач, але він часто працює
надто довго, не вкладаючись в обмеження часу. А тут вкладається, бо
вершин всього 8.

Нажаль, ідея \<\<писати осмислений алгоритм, щоб обробляти різні вхідні
дані однотипно\>\> мало придатна до заданої рисунком відповідності ребер
куба його вершинам. Важко сформулювати, між якими са́ме вершинами є
ре́бра. (Найкраще, що вдалося--- *\<\<Позначки вершин відрізняються або
на 4, або на 1, але крім $d{\leftrightarrow}e$, а крім названих, є ще
$a{\leftrightarrow}d$ і$e{\leftrightarrow}h$\>\>*.) Мабуть, легше задати
явний перелік (чияк урозв'язку з попереднього абзацу, чи вписати у текст
програми константний масив--- матрицю суміжності графа, чище якось). Але
це треба ретельно звіряти з умовою, бо успішна побудова шляхів у одній
частині графа ніяк неперевіряє правильність задання ребер у іншій
частині.

[]{#text:log-cube-how-to-get-part-of-points-easily
label="text:log-cube-how-to-get-part-of-points-easily"} Тести цієї
задачі такі, що програма, яка, не вирішуючи задачу посуті, завжди
виводить "`NO`", набирає 90балів з 300. Можливо, це й несправедливо
багато. Але зумови (тазтого, що у 2013 р. використовувалося лише
потестове оцінювання) очевидно, що така програма мусила хочщось та
набрати; хто неміг розв'язати правильно--- мавби пошукати якісь такі
варіанти. Трохи чесніший спосіб--- перевіряти, чиє вершини кінцями
одного ребра́, іякщо так, то виводити ці вершини, аякщоні, то"`NO`". Він
набирав 150балів (рівно половину).
