Легенда задачі відірвана від життя, ці правила не мають нічого спільного
з реальною генерацією паролів. Тимнеменш, будемо користуватися термінами
\<\<пароль\>\> і \<\<номер паролю\>\>, раз вони введені в умові.

Правила про порядок можна спростити до таких:

1.  будемо вважати алфавітом `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`,
    `I`, `J`, `K`, `L`, `M`, `N`, `O`, `P`, `Q`, `R`, `S`, `T`, `U`,
    `V`, `W`, `X`, `Y`, `Z`, `0`, `1`, `2`, `3`, `4`, `5`, `6`,
    `7`, `8`, `9` (са́ме в такому порядку);

2.  всере́дині кожного пароля (крім 1-символьних), кожен наступний символ
    мусить бути строго більшим за попередній (згідно алфавіту п. 1).

Правила порівняння різних паролів не міняються (але примітка \<\<літери
менші за цифри\>\> тепер слідує з \<\<алфавітного порядку\>\>).

Оскільки в умові сказано, що досить багато балів припадає на не дуже
великі значення $n$, можна писати перебір, тобто дійсно генерувати
послідовно 1-й, 2-й,... паролі аж до$n$-го. Виявляється, при цьому
недуже важко добитися, щоб генерувалися відразу лише допустимі (згідно з
умовою задачі) паролі.

Розглянемо простіший випадок. Нехай потрібно вивести послідовно пари
(1,2), (1,3), (1,4), (1,5), (2,3), (2,4), (2,5), (3,4), (3,5), (4,5),
тобто пари з чисел від 1 до 5, щоб 2-й елемент пари завжди був строго
більшим за1-й. Цеможна зробити за допомогою циклів та `if`-а, як у
лівому стовпчику
рис. [1](#fig:check-or-gen-only-needed){reference-type="ref"
reference="fig:check-or-gen-only-needed"}. А можна, як у правому,
замінити *перевірку* ${i{<}j}$ на *задання лише потрібного* діапазону.

<figure id="fig:check-or-gen-only-needed">
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><div class="small">
<p><code>for</code><code>i:=1</code><code>to</code><code>5</code><code>do</code><br />
<code>for</code><code>j:=1</code><code>to</code><code>5</code><code>do</code><br />
<code>if</code><code>i</code><code>&lt;</code><code>j</code><code>then</code><br />
<code>writeln(i,</code><code>’,</code><code>’,</code><code>j);</code></p>
</div></td>
<td style="text-align: left;"><div class="small">
<p><code>for</code><code>i:=1</code><code>to</code><code>4</code><code>do</code><br />
<code>for</code><code>j:=i+1</code><code>to</code><code>5</code><code>do</code><br />
<code>writeln(i,</code><code>’,</code><code>’,</code><code>j);</code></p>
</div></td>
</tr>
</tbody>
</table>
</div>
<figcaption>Два способи генерації однієї послідовності пар</figcaption>
</figure>

Для 2-х вкладених циклів це дрібна оптимізація ($\approx$ удвічі). Але
якщо застосувати ту саму ідею до циклів більшої вкладеності,
пришвидшення істотне: для п'яти вкладених циклів$\approx$сотні разів,
для десяти--- $\approx$мільйони. (Доведення потребу́є знань
комбінаторики, аленедуже глибоких, тож пропонується як вправа. Дотогож,
писати програму можна й без доведення...)

Приклад такого розв'язку --- . Цезовсімневзірець красоти й лаконічності.
У ньому легко допустити і важко шукати технічні помилки. Але він все ж
набирає чимало балів.

Перш за все, загальна кількість $k$-символьних паролів рівна $C(36, k)$,
де $C(n,k)$, воно ж $C_n^k$ --- кількість *сполучень* (рос. *сочетания*,
англ. *combinations*) з $n$ по $k$. Це так, бо з 36символів вибираються
$k$ різних, і одні й ті самі вибрані символи не можна переставляти
місцями, бо дозволений лише порядок за зростанням (у алфавіті
`A`, `B`, ..., `Z`, `0`, `1`, ..., `9`).

Так що почнемо розв'язок з того, що взна́ємо довжину (кількість символів)
шуканого пароля і його номер *серед паролів цієї довжини*.

::: normalsize
-   Наприклад, прочитали у вхідних даних 2015.

-   Кіль-ть 1-символьних паролів ${C(36,1){=}36}$, ${36{<}2015}$---
    отже, у паролі більше одного символу, й номер серед
    (більш-ніж-1)-символьних ${2015-36=1979}$.

-   Кіль-ть 2-символьних паролів ${C(36,2){=}630}$, ${630{<}1979}$---
    отже, у паролі більше двох символів, і номер серед
    (більш-ніж-2)-символьних ${1979-630=1349}$.

-   Кіль-ть 3-символьних паролів ${C(36,3){=}7140}$, ${7140{\>}1349}$---
    отже, пароль 3-символьний, ійого номер серед 3-символьних
    рівний 1349.
:::

Узнавши довжину пароля та його номер серед паролів відповідної довжини,
починаємо взнавати цей пароль символ за символом, зліва направо --- на
тій підставі, що для кожного можливого початку можна взнавати (засобами
комбінаторики) кількість паролів з таким початком і знову приймати
рішення, чицей початок треба пропустити (всі паролі з таким початком
мають менші номери), чивикористати (потрібний номер якраз потрапляє у
діапазон).

::: normalsize
-   Продовжимо аналіз того самого прикладу (вхідний номер 2015, раніше
    з'ясовано, що його номер серед 3-символьних рівний 1349).

-   Кіль-ть 3-символьних паролів, що починаються з `A`, рівна
    ${C(35,2) = 595}$, бо продовження 2-символьне з 35 символів (від `B`
    до `9`). ${1349>595}$--- отже, початок паролю не `A`, аякийсь
    подальший символ, і номер серед тих подальших ${1349-595=754}$.

-   Кіль-ть 3-символьних паролів, що починаються з `B`, рівна
    ${C(34,2) = 561}$, бо продовження 2-символьне з 34 символів (від `C`
    до `9`). ${754>561}$--- отже, початок паролю не `B`, аякийсь
    подальший символ, і номер серед тих подальших ${754-561=193}$.

-   Кіль-ть 3-символьних паролів, що починаються з `C`, рівна
    ${C(33,2) = 528}$, бо продовження 2-символьне з 33 символів (від `D`
    до `9`). ${193\<528}$--- отже, початок паролю якраз-таки `C`, і його
    номер серед 3-символьних, щопочинаються з `C` --- теж 193.

    -   Далі відбувається аналогічний підбір наступного символу:

    -   Кіль-ть 3-символьних паролів, що починаються з "`CD`", рівна
        ${C(32,1)=32}$, бо лишається дописати один символ, від `E`
        до `9`. ${193>32}$--- отже, 2-га літера не `D`, аякийсь
        подальший символ, і номер серед тих подальших ${193-32=161}$.

    -   І так далі.

    -   Продовживши аналогічні міркування, отримаємо, що шуканий пароль
        16-й серед тих, що починаються з "`CJ`", а оскільки після `J`
        можуть іти лише символи, починаючи з `K`, то цим 16-м буде `Z`.

-   Остато́чно, 2015-й пароль має вигляд "`CJZ`".
:::

Ці пояснення займають багато місця, але лише тому, що наведено приклад.
Правильна реалізація цього комбінаторного алгоритму працює дуже швидко,
вкладаючись у секунду з величезним запасом. Адже всього-то треба:

1.  Познаходити $C(n,k)$, наприклад, усі зразу із проміжку
    $0\dib{{\<}}k\dib{{\<}}n\dib{{\<}}36$ за допомогою трикутника
    Паскаля;

2.  Знайти кількість символів у паролі --- віднімати циклом $C(36,1)$,
    $C(36,2)$, ...; якби дійшли до $C(36,36))$, аномер після усіх
    віднімань все ще лишався надто великим --- це означало б, що пароля
    вказаних вигляду і номера взагаліне існує. Але такого не буде, бо
    паролів ($2^{36}-1$) все-таки більше, чим $n{\<}10^{10}$. Значить
    --- тут не більш як 36 порівнянь та віднімань;

3.  Для кожної позиції (1-йсимвол, 2-й, ...) запустити цикл, щоб знайти
    конкретне значення відповідного символу--- тежне багато, бо
    іпозицій, ізначень символів не більше 36.

Від вираження асимптотичної оцінки складності алгоритму типовим чином
(через $n$ зі вхідних даних) утримаємось, бо надто багато залежить від
розміру алфавіту, а залежність часу роботи від значення $n$ заплутана.
*Якби* розмір алфавіту був змінним (і при цьому не з'являлася
\<\<довга\>\> арифметика), можна було б говорити про час роботи
$O(A^2)$, де$A$--- розмір алфавіту. []{#label:201415-3-C-finish
label="label:201415-3-C-finish"}
