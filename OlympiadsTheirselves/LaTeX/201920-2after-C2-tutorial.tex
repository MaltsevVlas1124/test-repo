~

\smallskip

\vspace{-\baselineskip}

\Tutorial
Тут мається на увазі розбір особливостей задачі з урахуванням того, що вона дана у варіанті <<з~\mbox{header-ом} та \mbox{footer-ом}>>; розбір суто алгоритмічної її складової можна знайти через повідомлення у згаданому змаганні~70 сайту \EjudgeCkipoName{} або за \href{https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108}{\emph{цим прямим посиланням}}.

\MyParagraph{Короткий огляд основних властивостей підходу з header-ами та footer-ами}
\begin{enumerate}
\item
Фрагмент \texttt{sample}, який Ви маєте дописати, \underline{\emph{не}}~містить точки входа у програму (функції \texttt{main}~(C++)~/ головної програми (Pascal)~/ м\'{е}тода \texttt{main} (Java)), і це слід так і зберегти. Точка входу (головна програма чи функція/\nolinebreak[2]метод \texttt{main}) все одно \underline{\emph{є}} у частині footer (мовою Java\nolinebreak[3] --- частині header, але в будь-якому разі в частині, написаній автором задачі, а~не~Вами), тож якщо Ви напишите ще одну точку входу --- найімовірніше, програма просто не~скомпілюється. А~якщо і скомпілюється (це\nolinebreak[3] можливо, зокрема, мовою Паскаль, де\nolinebreak[2] все після ``\texttt{END.}'' головної програми ігнорується), то Ви не~знаєте всіх особливостей, які відрізняють <<секретний>> footer від вказаного на початку умови. Зокрема (але~не~тільки), в~цій задачі <<секретний>> footer читає вхідні дані з деякого файлу, і~Вам свідомо не~повідомляють, як він називається. Тож замінити розроблену журі точку входу своєю Ви, найімовірніше, не~зможете (а~якщо і зможете, то неясно, яка в тому користь).
\item
Фрагмент \texttt{sample}, який Ви маєте дописати, \underline{\emph{не}}~читає вхідні дані з клавіатури/\nolinebreak[2]файлу й \underline{\emph{не}}~виводить результат на~екран чи у~файл; це~треба так і залишити; все~це робить footer (написаний автором задачі, а~не~Вами). Тим паче, с\'{а}ме в цій задачі Ви не~знаєте, звідки читати й куди виводити. А~якби і знали, то \emph{зайві} читання та/або виведення призводили~б до порушення формату введення/\nolinebreak[3]виведення (яке, досить непередбачувано, може дати чи~то вердикт ``Помилка виконання'', чи~то ``Неправильний формат відповіді'', %%% чи~то ``Неправильна відповідь'',
тощо).
\item
Фрагмент \texttt{sample}, який Ви маєте дописати, зобов'язаний містити реалізацію кожної з підпрограм (функцій/\nolinebreak[3]процедур/\nolinebreak[3]м\'{е}тодів), які Вам дано завдання реалізувати. Навіть якщо Ви вважаєте, що така дія непотрібна для досягнення остат\'{о}чного результату (що с\'{а}ме в цій задачі, насправді, не~так)\nolinebreak[3] --- хоча~б не~прибирайте вже наявні оголошення й порожні реалізації.
\item
Фрагмент \texttt{sample}, який Ви маєте дописати, \underline{\emph{може}}, якщо Вам так зручно, містити також додаткові Ваші підпрограми (функції/\nolinebreak[3]процедури/\nolinebreak[3]м\'{е}тоди) та/або Ваші типи, включаючи класи.
\item
Фрагмент \texttt{sample}, який Ви маєте дописати, \underline{\emph{може}}, якщо Вам так зручно, \emph{містити організовану Вами додаткову інформацію, що зберігається між викликами тих підпрограм, які Вам слід реалізувати}.
Це можуть бути змінні будь-яких типів, включно з масивами та/або об'єктами (примірниками класів):
\begin{enumerate}
\item
для С++ та Pascal це можуть бути глобальні змінні;
\item
для Java це можуть бути статичні пол\'{я} всер\'{е}дині того класу, в~якому Вам слід реалізувати вказані м\'{е}тоди.
\end{enumerate}
(\emph{Підказка}: варто, щоб підпрограма \texttt{init} заповнювала ті глобальні змінні чи статичні пол\'{я} результатами передобробки, а підпрограма \texttt{calcRectSum} використовувала їх для свого пришвидшення.)
\item
Коментарі з текстом ``\texttt{TODO}'', наявні у фрагменті \texttt{sample}, рекомендують с\'{а}ме там і дописувати Ваш код, але ні до чого істотного не~зобов'язують. Їх~можна прибирати (для компілятора це просто коментарі); можна (і~нерідко треба) писати свій код також у деяких інших місцях фрагмента \texttt{sample}; тощо. Але якщо не~вписувати свій код ні~в~які з місць, позначених коментарями ``\texttt{TODO}'', правильного розв'язку не~вийде.
\end{enumerate}

\MyParagraph{Як мені локально (на своєму комп'ютері) запускати код, поділений між трьома файлами?}
Можна просто <<склеїти>> (наприклад, копіюваннями та вставками тексту, або написавши у командному рядку \centerline{\begin{small}\begin{ttfamily}copy "201920-2a-C-header-g++.cpp"+"201920-2a-C-sample-g++.cpp"+"201920-2a-C-footer-g++.cpp"\ C-all.cpp\end{ttfamily}\end{small}} або ще якось) \mbox{\texttt{header}-,} \texttt{sample}- та \texttt{footer}-фрагменти (с\'{а}ме в цьому порядку) в\nolinebreak[3] один файл. Кому це зручно\nolinebreak[3] --- може так і робити (тим\nolinebreak[3] паче, що тепер є вибір\nolinebreak[3] --- чи\nolinebreak[3] традиційно здавати файл із розв'язком, чи\nolinebreak[3] потрібну частину коду виділяти й копіювати у\nolinebreak[3] середовищі програмування та вставляти безпосередньо у сторінку ejudge). Але\nolinebreak[3] в\nolinebreak[3] цього простого підходу є недолік: при кожній спробі надіслати розв'язок в ejudge треба вибирати й копіювати ту \emph{частину} коду, яка є дописаною версією колишнього фрагменту \texttt{sample}. Це\nolinebreak[3] і\nolinebreak[3] займає час, і\nolinebreak[3] збільшує ризик помил\'{и}тись і здати щось\nolinebreak[2] не~те.
(Зазвичай, це призводитиме до помилки компіляції; але за деяких обставин можливі й якісь інші викривлення процесу перевірки, й аналіз результатів таких викривлених перевірок може змарнувати багато часу й зусиль. Особливо, мовою Pascal, де весь вміст файлу після ``\texttt{END.}'' головної програми ігнорується.)
Том\'{у}, непогано було~б мати спосіб здавати в ejudge повний вміст усього файлу.
%, нічого (крім файлу в\nolinebreak[2] ціл\'{о}му) не~вибираючи.
% На~жаль,  автор тексту не~може порекомендувати справді доброго такого способу.

\myflfigaw{\hspace*{-1.5em}\begin{ttfamily}
\begin{footnotesize}
\raisebox{0pt}[7\baselineskip][6\baselineskip]{\fbox{\begin{minipage}{20em}\#ifdef \_DEBUG\\
... (багато рядків — увеcь вміст файлу\\
"201920-2a-C-header-g++.cpp") ...\\
\#endif\\[1.5ex]
... (багато рядків — увеcь вміст\\
відредагованого Вами колишнього файлу\\
"201920-2a-C-sample-g++.cpp") ...\\[1.5ex]
\#ifdef \_DEBUG\\
... (багато рядків — увеcь вміст\\
(можливо, відредагованого Вами)\\
колишнього файлу\\
"201920-2a-C-footer-g++.cpp") ...\\
\#endif\end{minipage}}}%
\end{footnotesize}%
\end{ttfamily}}
Один з не~універсальних, але реальних способів такий: \underline{\begin{bfseries}\begin{itshape}якщо\end{itshape}\end{bfseries}} Ви пишете мовою~\mbox{C++} і користуєтеся на своєму комп'ютері \begin{bfseries}\begin{itshape}Micro\-soft Visual Studio в~Debug-режимі\end{itshape}\end{bfseries}, можна робити, як вказано праворуч, і\nolinebreak[3] виходитиме, що фрагменти від ``\texttt{\#ifdef \_DEBUG}'' до ``\texttt{\#endif}'' будуть компілюватися й виконуватися на Вашому локальному комп'ютері, але пропускатимуться при компіляції (а~отже, й~виконанні) на\nolinebreak[2] ejudge. 
Якщо Ви хочете користуватися локально іншим середовищем програмування (або студією в~іншому режимі), то для користування цим прийомом треба % хоч\nolinebreak[3] трохи 
розібратися з так званою \emph{умовною компіляцією}, і \emph{самостійно} робити, щоб у\nolinebreak[3] Вашому середовищі програмування (не~в~цій\nolinebreak[2] самій програмі, яка здаватиметься в ejudge, а~в~середовищі (IDE), в~якому Ви запускаєте цю програму на Вашому локальному комп'ютері) було означене (defined) деяке ім'я, не~означене на~сервері ejudge.

Для Pascal ніби й досить замінити 
``\texttt{\#ifdef ...}''
на 
``\texttt{\{\$ifdef ...\}}''
та
``\texttt{\#endif}''
на 
``\texttt{\{\$endif\}}'',
але конкретно слово ``\_DEBUG'', найімовірніше, не~спрацює. Треба знайти аналогічне слово, означене (defined) с\'{а}ме у Вашому середовищі, але не~на~ejudge (або зробити таке означення самостійно). 
%
Як (і~чи~можна) зробити щось аналогічне для Java, автору тексту невідомо (умовної компіляції в Java, начебто, не~існує, а~просто розкласти різні класи по різним файлам не~можна, бо для <<звичайної>> компіляції багатофайлового проєкту ті класи повинні бути \texttt{public}, а~для тієї, що відбувається в~ejudge, вони не~можуть бути \texttt{public}).

Якщо хтось може запропонувати зручніші чи універсальніші способи\nolinebreak[3] --- прохання 
% повідомити про деталі 
так і зробити
(питанням у \EjudgeCkipoName, чи \href{http://codeforces.com/usertalk?other=IlyaCk}{повідомленням користувачеві \texttt{IlyaCk}} на сайті \href{https://codeforces.com}{\texttt{codeforces.com}}, чи ще якось).

\MyParagraph{Редагувати можна \underline{\emph{тільки}} фрагмент <<\texttt{sample}>>?}
Залежить від того, як і навіщо. Наприклад, підключити у header 100 бібліотек і використовувати їх у sample\nolinebreak[3] --- дуже погана ідея, бо хоч воно і працюватиме на\nolinebreak[3] локальному комп'ютері, на\nolinebreak[2] ejudge не~скомпілюється, бо тих додаткових бібліотек як не~було, так і нема у\nolinebreak[3] \mbox{header-і}, підготовленому журі. 
Але, наприклад, якщо в наданому журі \mbox{footer-і} вхідні дані читаються з~клавіатури, а~Ви\nolinebreak[2] хочете з~файлу (чи~навпаки)\nolinebreak[3] --- \emph{таке} редагування \mbox{footer-а} може бути доброю ідеєю; причому, Вам не~треба буде при здачі в ejudge перероблювати спосіб введення на початковий, бо Ваші правки \mbox{footer-а} лишаться на Вашому комп'ютері й не~вплинуть на перевірку на ejudge.

Є~й~чимало інших випадків, коли доцільно редагувати footer (див.~далі); 
потреба редагувати header з'являється значно рідше, але іноді все~ж буває.
Наприклад, Ви можете підключити у своєму header-і бібліотеки, що будуть використовуватися лише у Вашому footer-і. Тільки тоді треба слідкувати, щоб не~використати ті додаткові бібліотеки в основній частині, що здаватиметься в ejudge.

\MyParagraph{Чи~є ще якісь переваги для учасника в цього підходу з header-ами та footer-ами?}
Їх,\nolinebreak[3] насправді, чимало (хоч вони й \mbox{незвичні} та неоче\-видні тим, хто досі з~таким не~стикався; 
само собою, незручності в такого підходу теж~є, але зараз не~про~них).
Одна з таких переваг\nolinebreak[3] --- зникає дуже вже велика залежність часу (тривалості) роботи програми учасника від використаних засобів читання вхідних даних та виведення результатів (для~C++,\nolinebreak[2] \texttt{scanf} та \texttt{printf} проти \texttt{cin} та \texttt{cout}; для\nolinebreak[2] java, поєднання \texttt{FileReader}, 
\texttt{BufferedReader} та 
\texttt{StreamTokenizer}
проти 
\texttt{Scanner}\nolinebreak[3] --- такі зміни, будучи технічними, а~не~алгоритмічними, кардинально впливають на оцінку розв'язку, бо загальний час роботи всієї програми (найефективнішого з алгоритмів, двовимірного узагальнення префіксних сум; див.\nolinebreak[3] \href{https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108}{\emph{розбір алгоритмічної складової задачі}}) відрізняється не~на~відсотки і навіть не~на~десятки відсотків, а~у~багато разів).
Див. також наступний пункт.

\MyParagraph{Зручність підходу з header-ами та footer-ами для порівняння результатів різних алгоритмів.}
(Часто, але не~завжди, це основна перевага цього підходу з точки зору учасника.)
У~цій задачі не~проблема написати <<лобовий>> розв'язок, де \texttt{calcRectSum} додає всі значення відповідного прямокутника-запиту поелементно. Само собою, цей <<лобовий>> розв'язок не~має шансів пройти щось більше, ніж блоки\nolinebreak[2] \mbox{1--2}, тож для\nolinebreak[2] отримання більших балів слід писати щось ефективніше (див.\nolinebreak[3] \href{https://ejudge.ckipo.edu.ua/coll_new_A4_11pt.pdf#page=108}{\emph{розбір алгоритмічної складової задачі}}). 
Те\nolinebreak[3] ефективніше виявляється складнішим (особливо, коли не~читати готові формули у розборі, а\nolinebreak[3] самостійно придумувати їх під час туру), в\nolinebreak[3] ньому легше допуститися помилок, і\nolinebreak[3] з\nolinebreak[3] цим треба якось працювати. Зокрема, шукати помилки в ефе\-ктив\-ні\-шій\&склад\-ні\-шій версії \texttt{calcRectSum}, якщо вона працює правильно часто, але~не~завжди, й~ejudge це ловить, а~Ви\nolinebreak[2] не~бачите, \emph{коли} виникають помилки.

{
\def\tabbb{\hspace*{0.75em}}
\myflfigaw{\hspace*{-1.5em}\raisebox{0pt}[2\baselineskip][3\baselineskip]{\mbox{\begin{ttfamily}\begin{footnotesize}\begin{minipage}{20.5em}\renewcommand{\baselinestretch}{0.5}for i1:=1 to N do\\[-.5ex]
\tabbb{}for i2:=i1 to N do\\[-.5ex]
\tabbb\tabbb{}for j1:=1 to M do\\[-.5ex]
\tabbb\tabbb\tabbb{}for j2:=j1 to M do begin\\[-.5ex]
\tabbb\tabbb\tabbb\tabbb{}res1:=calcRectSum(i1,i2,j1,j2);\\[-.5ex]
\tabbb\tabbb\tabbb\tabbb{}res2:=calcRectSumSlow(i1,i2,j1,j2);\\[-.5ex]
\tabbb\tabbb\tabbb\tabbb{}if res1<>res2 then begin\\[-.5ex]
\tabbb\tabbb\tabbb\tabbb\tabbb{}... ... ...;\\[-.5ex]
\tabbb\tabbb\tabbb\tabbb{}end\\[-.5ex]
\tabbb\tabbb\tabbb{}end\end{minipage}\end{footnotesize}\end{ttfamily}}}}
Тут\nolinebreak[2] часто корисно робити, як праворуч: ефе\-ктив\-ні\-шу\&склад\-ні\-шу \texttt{calcRectSum} розмістити у sample-фра\-г\-мен\-ті, а\nolinebreak[2] підпрограму з <<лобовим>> підходом назвати \texttt{calcRectSumSlow} та розмістити у footer-фра\-г\-мен\-ті; зробити, щоб у footer-фрагменті послідовність пря\-мо\-кут\-ни\-ків-за\-пи\-тів не~читалася зі вхідних даних, а~перебиралися всі можливі варіанти, і при знаходженні відмінності результатів двох алгоритмів, наприклад, тут~же виводилося, де~с\'{а}ме (при\nolinebreak[2] яких \texttt{i1}, \texttt{i2}, \texttt{j1},~\texttt{j2}) це сталося. Й~усе\nolinebreak[3] це можна організувати так, щоб sample-фрагмент лишався у вигляді, цілком готовому до негайної здачі в ejudge.

Звісно, такий запуск реалізацій і порівняння результатів\nolinebreak[3] --- не~панацея; він не~знайде помилок, однакових в обох реалізаціях (наприклад, коли і~там, і~там є однакове переповнення типу), чи якусь проблему, що виникає лише на настільки великих розмірах масиву та прямокутників-запитів, що чекати <<лобового>> підходу задовго\dots{} Але це все~ж спосіб шукати помилки, доступний під час туру (навіть без ejudge!), і є чимало ситуацій, коли ним варто скористатися. Й~у~варіанті з header-ами та footer-ами все~це робити зручніше, ніж у~традиційному.

}

\MyParagraph{У 72-му змаганні відкрита частина тестів, так вони в геть зовсім різному форматі; частина схожа на формат 70-го змагання (й то не~зовсім), а~частина геть не~схожі.}
Так~і~є. Але учасникам просто не~треба про~це хвилюватися. Просто робіть ту частину, яка випливає з умові задачі та загальних правил і традицій <<алгоритмічних>> олімпіад (\begin{slshape}<<реалізувати підпрограму \texttt{calcRectSum} якнайефективніше, враховуючи, що суми треба рахувати багатократно для різних прямокутників одного масиву, і що Вам дається можливість один раз зробити передобробку в~підпрограмі \texttt{init}>>\end{slshape}), і не~надто звертайте увагу на те, що там читається з файлу/\nolinebreak[2]клавіатури та виводиться на екран чи у~файл.

А~те,\nolinebreak[2] що\nolinebreak[2] у~\mbox{72-му}\nolinebreak[3] змаганні найбільші тести не~читаються з~файлу повністю, а~частково читаються й частково догенеровуються у\nolinebreak[2] \mbox{footer-і} секретним для учасників способом\nolinebreak[3] --- насправді ще~одна \emph{перевага} \mbox{підходу} з header-ами та footer-ами. Адже це дозволяє різко зменшити (вже згадану і дуже істотну для <<традиційної>> версії цієї задачі з\nolinebreak[3] \mbox{70-го}\nolinebreak[3] змагання) проблему, що читання вхідних даних і виведення результату займає дуже вже значну частину всього часу виконання програми. У~ще~більшій мірі стає правдою, що виграють ті, хто може запропонувати кращий спосіб вирішення основної задачі (реалізувати підпрограму \texttt{calcRectSum} якнайефективніше), а~не~ті, хто добре знає всякі прийоми швидкого читання, які в~цілому корисні, але не~мають ніякого стосунку до конкретної задачі.