Таке \<\<рівняння\>\> не має стандартних аналітичних засобів
розв'язування, тож справді треба якось перебирати різні потенційно
можливі варіанти й перевіряти, які з них дають розв'язок. Але перебір
\<\<в лоб\>\> (длякожного$n$ від$a$ до $b$ рахувати суму квадратів цифр
і перевіряти виконання чи не виконання \<\<рівняння\>\>) надто довгий,
аж до $10^{18}$ ітерацій (час роботи --- багато років). Тому, перебір
треба суттєво оптимізувати. Помітимо такі факти:

1.  Щоб виконалася рівність $k\times{}f(n)=n$, число$n$ мусить бути
    кратним $k$, тож можна зразу перебирати лише ті чи́сла від$a$ до $b$,
    які кратні $k$ (у цієї ідеї є дещо частково спільне з ідеями зі
    стор.  та ).

2.  На всьому проміжку до $10^{18}$ найбільшу суму квадратів цифр має
    \[1ex\]\[0ex2ex\]$\underbrace{99\dots9}_{18\textnormal{\footnotesize{ штук}}}$,
    тому для всіх $n$ виконується
    ${f(n)}\dib{{\<}}{18{\times}9^2}\dib{{=}}1458$.

Тобто, перебір можна почати з найменшого $n$, одночасно кратного $k$ і
більшого або рівного $a$, і продовжувати, збільшуючи щоразу на $k$, доки
не виявиться більшим $\min(b,\dib{{}}{1548{\times}k})$ (у програмі,
мабуть, зручніше писати "`while (n<=b) and (n<=18*81*a)`". Очевидно,
такий цикл повторюватиметься нія́кнебільше 1548разів, що для комп'ютера
зовсім мало. Лишається тільки реалізувати це акуратно, щоб не було
проблем ні з переповненнями типу `int64` (`long long`), ні з похибками
(якщо використовувати для проміжних обчислень типи з рухомою комою).
Наприклад, .
