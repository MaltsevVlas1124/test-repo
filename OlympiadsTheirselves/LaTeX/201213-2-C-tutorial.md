Найочевидніший підхід (справді перебрати всі чи́сла від$A$ до $B$,
перетворити у двійкове подання і для кожної пари сусідніх справді
порівняти й порахувати біти) і не такий простий (як,власне, порівнювати
біти?), і не має шансів узяти повні бали, бо, навіть якби кожна пара
чисел порівнювалася за один процесорний такт (насправді явно більше),
всеодно при ${A\,{\approx}\,1}$, ${B\,{\approx}\,10^{10}}$ цебуло б
кілька секунд.

Оскільки використання того, що чи́сла в комп'ютері *вже* у двійковій
системі, буває корисним у багатьох інших ситуаціях, пропонуємо охочим
подивитися в , як варто було б технічно реалізовувати цей
підхід.Змінна`k` послідовно набуває значень $1_{2}$, $10_{2}$,
$100_{2}$, ...;"`&`"єпобітовим `and`-ом;отже, `i&k` являє собою або 0
(коли відповідний біт числа́`i` рівний 0), або `k` (якщо рівний 1); отже,
умова `(i&k)``!=``((i+1)&k)` виражає, що черговий біт чисел `i` та `i+1`
всеще рі[*з*]{.underline}ний (не однаковий). Крім того, з
${(\texttt{i+1})}\dib{{-}}\texttt{i}\dibbb{{=}}1$ випливає, що різними
бітами в цих числах можуть бути *лише* кінець ${011\dots1}$в`i` та
відповідний йому кінець ${100\dots0}$в`i+1` (кількість одиниць, що
перетворюються у нулі, може бути різною, в т. ч. 0; потім рівно один
нуль перетворюється в одиницю); яктільки деякий біт однаковий--- всі
лівіші теж, цикл можна обривати.

І навіть така, досить вилизана у деталях, реалізація цього підходу
набирає лише 50% балів.

Розглянемо таблицю, в якій записані чи́сла від 1 до
$18_{Dec}\dib{{=}}10010_2$ та кількості розрядів, які змінюються при
переході *до*цього числа́ від попереднього.

  --- -------------------------------- -------------------------------- --------------------------------- --------------------------------- --------------------------------- --------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ----------------------------------- ----------------------------------- -----------------------------------
   1                 2                                3                                 4                                 5                                 6                                 7                                 8                                  9                                  10                                 11                                 12                                 13                                 14                                 15                                 16                                  17                                  18
   1   [[10]{.underline}]{.underline}   1[[1]{.underline}]{.underline}   [[100]{.underline}]{.underline}   10[[1]{.underline}]{.underline}   1[[10]{.underline}]{.underline}   11[[1]{.underline}]{.underline}   [[1000]{.underline}]{.underline}   100[[1]{.underline}]{.underline}   10[[10]{.underline}]{.underline}   101[[1]{.underline}]{.underline}   1[[100]{.underline}]{.underline}   110[[1]{.underline}]{.underline}   11[[10]{.underline}]{.underline}   111[[1]{.underline}]{.underline}   [[10000]{.underline}]{.underline}   1000[[1]{.underline}]{.underline}   100[[10]{.underline}]{.underline}
   1                 2                                1                                 3                                 1                                 2                                 1                                 4                                  1                                  2                                  1                                  3                                  1                                  2                                  1                                   5                                   1                                   2
  --- -------------------------------- -------------------------------- --------------------------------- --------------------------------- --------------------------------- --------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ---------------------------------- ----------------------------------- ----------------------------------- -----------------------------------

З неї легко бачити, що для непарних чисел змінюється 1 розряд; парних,
аленекратних 4, змінюються 2 розряди; кратних 4, аленекратних 8,
змінюються 3 розряди; і т. д. (Ценеважко й довести: коли число
кратне $2^{k}$, аленекратне $2^{k+1}$, його двійковий запис закінчується
на рівно $k$ нулів; при переході до цього числа́ від попереднього,
змінюються вони всі, та ще один біт.)

А звідси вже можна порахувати, що на всьому проміжку від 1 до
деякого $N$ шукана сума всіх кількостей змін розряду може бути
порахована як

$$% % % $K(N) = N\dibbb{{+}}{(N\mathbin{\mathrm{div}}2)}\dibbb{{+}}{(N\mathbin{\mathrm{div}}2^2)\,{+}\,\dots}\dibbb{{+}}{(N\mathbin{\mathrm{div}}2^k)\,{+}\,\dots}$,
K(N) = N + (N\mathbin{\mathrm{div}}2) + (N\mathbin{\mathrm{div}}2^2) + \ldots + (N\mathbin{\mathrm{div}}2^k) + \ldots,
\label{eq:201213-2-C-binary}$$

де $\mathbin{\mathrm{div}}$--- цілочисельне ділення; сума, хоч і
завершується трикрапкою, фактично має лише приблизно $\log_2{N}$
доданків (далі нулі). Чому така формула відповідає тому, що було
наведено у табличці та подальших міркуваннях? Бо$N$--- кількість взагалі
всіх чисел у діапазоні, й для непарних вже пораховано правильно, а для
всіх парних з потрібної кількості взято 1; далі,
${(N\mathbin{\mathrm{div}}2)}$--- кількість всіх парних чисел у
діапазоні, й для парних не кратних 4 вже пораховано правильно (один
раніше й один зараз), а для всіх кратних 4 з потрібної кількості
взято 2; і т. д.

Ця формула працює лише \<\<[*від 1*]{.underline} до деякого $N$\>\>,
атреба від $A$ до $B$. Тому суму від $A$ до $B$ варто виразити як
${K(B)\,{-}\,K(A)}$ (у більшості схожих ситуацій, як настор.--,
${K(B)}\dib{{-}}{K(A\,{-}\,1)}$, зміркувань \<\<$A$ у проміжку, його
виключати не треба\>\>, атут все-таки ${K(B)\,{-}\,K(A)}$, бо перехід
від ${A\,{-}\,1}$ до $A$ не входить у потрібний
проміжок).[]{#text:201213-2-C-about-range-subtract
label="text:201213-2-C-about-range-subtract"}

Реалізуйте описаний алгоритм самостійно. $K(N)$ варто оформити функцією
(підпрограмою), щоб могти викликати з різними значеннями аргумента,
не дублюючи сам код обчислень
згідно ([\[eq:201213-2-C-binary\]](#eq:201213-2-C-binary){reference-type="ref"
reference="eq:201213-2-C-binary"}). Така реалізація повинна працювати
практично миттєво, бо її складність всього лиш
${O(\log{B}\,{+}\,\log{A})}\dibbb{{=}}{O(\log{B})}$. Такщообмеження
${B\,{\<}\,10^{10}}$ в цьому ракурсі сприймається як легкий тролінг, бо
і вимагає того ж 64-бітового типу даних, і схиляє до пошуку дещо
повільніших алгоритмів (як-то$O(\sqrt{B})$). Що ж,так теж буває...
