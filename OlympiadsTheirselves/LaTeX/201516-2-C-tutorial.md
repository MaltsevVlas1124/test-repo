[]{#label:find-n-th-perm-with-rep-begin
label="label:find-n-th-perm-with-rep-begin"} Задача має багато спільного
з задачею \<\<Генератор паролiв\>\> (стор. --). Тут теж варто знайти,
скільки всього можливих послідовностей починається з '`A`' іабо
побачити, щозадане у вхідних даних $n$ $\<$ цієї кількості (тоді
послідовність-відповідь починаєтьсяз '`A`' і слід продовжити підбирати
літери на подальших позиціях), або, упротилежному випадку, слід відняти
з заданого у вхідних даних $n$ кількість цих послідовностей
(щопочинаються з '`A`') і зробити те са́ме щодо послідовностей,
щопочинаються з '`B`','`C`', '`D`'.

Тож треба знаходити кількість послідовностей, що починаються з такої-то
послідовності літер (ітому відомо, зяких літер уяких кількостях
складаються можливі продовження). Виборки, де всі елементи розставляють
усіма можливими порядками, не змінюючи набір цих елементів, називають
*перестановками* (*permutations*). Якщо унаборі елементів, які
переставляють, є однакові (наприклад, "`ABCB`", причому, якщо обміняти
місцями одне '`B`' з іншим '`B`', це вважається тим самим способом), то
виборки називають *перестановками з повтореннями*, і їх кількість може
бути виражена як

$$\overline{P}(k_1, k_2, \dots, k_n) = \frac{(k_1+k_2+\dots+k_n)!}{k_1!\cdot{}k_2!\cdot\ldots\cdot{}k_n!},$$

де "!" означає факторіал, $k_1$, $k_2$, ...,$k_n$--- кількості елементів
кожного типу. (Звідки береться ця формула? Пропонуємо знайти улітературі
чиІнтернеті; при розв'язуванні задачі це не потрібне, досить знати саму́
формулу; але виведення і допомагає її запам'ятати, і може бути корисним
у інших ситуаціях.) В цій задачі, формула набуває вигляду
$\overline{P}(a, b, c, d) \dib{{=}} \ifBigStretch\displaystyle\fi\frac{(a+b+c+d)!}{a!\cdot{}b!\cdot{}c!\cdot{}d!}$.

Лишається тільки поєднати розглянуті міркування. Зробіть це самостійно.
Адля контролю правильності розглянемо приклад ${a\,{=}\,1}$,
${b\,{=}\,2}$, ${c\,{=}\,3}$, ${d\,{=}\,4}$, ${n\,{=}\,2015}$.

::: small
При початку на '`A`', можливих продовжень $\overline{P}(0,2,3,4)$, бо
якщо взяти на першу позицію '`A`', на подальші позиції не лишається
жодної '`A`', ${b\,{=}\,2}$ штук '`B`', ${c\,{=}\,3}$ штук '`C`',
${d\,{=}\,4}$ штук '`D`'.
$\ifBigStretch\displaystyle\fi\frac{(0+2+3+4)!}{0!\cdot2!\cdot3!\cdot4!}\dib{{=}}1260\dib{{<}}2015$,
тобто відповідь починається нена '`A`', анаодну зподальших літер, іномер
відповіді серед тих подальших дорівнює $2015\dib{{-}}1260\dib{{=}}755$.

При початку на '`B`', можливих продовжень $\overline{P}(1,1,3,4)$, бо
якщо взяти на першу позицію '`B`', на подальші позиції лишається
${a\,{=}\,1}$ штука '`A`', ${b\,{=}\,1}$ штука '`B`',
${c\,{=}\,3}$ штук '`C`', ${d\,{=}\,4}$ штук '`D`'.
$\ifBigStretch\displaystyle\fi\frac{(1+1+3+4)!}{1!\cdot1!\cdot3!\cdot4!}\dib{{=}}2520\dib{{\>}}755$,
тобто відповідь починається якраз на '`B`', ітреба шукати подальші
літери.

При початку на "`BA`", можливих продовжень $\overline{P}(0,1,3,4)$, бо
якщо взяти на перші дві позиції"`BA`", на подальші позиції лишається
${a\,{=}\,0}$ штук '`A`', ${b\,{=}\,1}$ штука '`B`',
${c\,{=}\,3}$ штук '`C`', ${d\,{=}\,4}$ штук '`D`'.
$\ifBigStretch\displaystyle\fi\frac{(0+1+3+4)!}{0!\cdot1!\cdot3!\cdot4!}\dib{{=}}280\dib{{<}}755$,
тобто відповідь починається нена"`BA`", амає на другій позиції одну
зподальших літер, іномер відповіді серед тих подальших дорівнює
$755\dib{{-}}280\dib{{=}}475$.

При початку на "`BB`", можливих продовжень
$\overline{P}(1,0,3,4)\dib{{=}}280\dib{{<}}475$, тож відповідь
починається нена"`BB`", амає на другій позиції одну зподальших літер,
іномер серед тих подальших рівний $475\dib{{-}}280\dib{{=}}195$.

При початку "`BС`", можливих продовжень
$\overline{P}(1,1,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{(1+1+2+4)!}{1!\cdot1!\cdot2!\cdot4!}\dib{{=}}840\dib{{\>}}195$,
тож відповідь починається якраз на '`BC`'.

При початку "`BСA`", можливих продовжень
$\overline{P}(0,1,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{\ifAfour(0+1+2+4)!\else(0{+}1{+}2{+}4)!\fi}{0!\cdot1!\cdot2!\cdot4!}\dib{{=}}105\dib{{<}}195$,
тож відповідь має на третій позиції одну зподальших літер, номер серед
подальших $195\dib{{-}}105\dib{{=}}90$.

При початку "`BСB`", можливих продовжень
$\overline{P}(1,0,2,4)\dib{{=}}105\dib{{\>}}90$, тож відповідь
починається на '`BCB`'.

При початку "`BСBA`", можливих продовжень
$\overline{P}(0,0,2,4)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{(0{+}0{+}2{+}4)!}{0!\cdot0!\cdot2!\cdot4!}\dib{{=}}15\dib{{<}}90$,
тож відповідь має на четвертій позиції одну зподальших літер, номер
серед подальших $90\dib{{-}}15\dib{{=}}75$.

Тепер треба правильно врахувати (наприклад, передбачити `if` для таких
ситуацій), що літер '`B`' спочатку було лише ${b\,{=}\,2}$ й тому
початок "`BСBB`" взагалі неможливий
(кількість$\,$=$\,$`<!-- -->`{=html}0) і тому треба продовжити,
перейшовши до "`BСBC`".

І так далі. Остато́чна відповідь--- "`BCBDDCDCAD`".
:::

У тексті це займає багато місця, але виконується такий алгоритм дуже
швидко--- сумарна кількість обчислень формули $\overline{P}(\dots)$
не перевищує $4\dibbb{{\times}}{(a\,{+}\,b\,{+}\,c\,{+}\,d)}$
(бокількість розрядів ${a\,{+}\,b\,{+}\,c\,{+}\,d}$, у кожному
пробуються, щонайбільше, '`A`', '`B`','`C`', '`D`'), тож загальна
кількість дій може бути виражена як ${O((a\,{+}\,b\,{+}\,c\,{+}\,d)^2)}$
навіть при не найкращій реалізації самої формули, яка щоразу заново
переобчислює факторіали; якщо ж зберігати готові факторіали, можна
оптимізувати усю разом узяту програму до
${\Theta(a\,{+}\,b\,{+}\,c\,{+}\,d)}$ (втім, при настільки малих $a$,
$b$, $c$, $d$ це несуттєво).[]{#label:find-n-th-perm-with-rep-end
label="label:find-n-th-perm-with-rep-end"}

У бібліотеці `algorithm` мови C++ є функція `next_permutation`, яка
дозволяє послідовно перебирати перестановки у порядку зростання (що й
треба у цій задачі), і яка правильно працює з будь-якими перестановками
(зповтореннями чибез). Так що можна сформувати `string s` зі значенням
"$\underbrace{\texttt{AA}\dots\texttt{A}}_{\textnormal{\begin{footnotesize}$a$~штук\end{footnotesize}}}
\underbrace{\texttt{BB}\dots\texttt{B}}_{\textnormal{\begin{footnotesize}$b$~штук\end{footnotesize}}}
\underbrace{\texttt{CC}\dots\texttt{C}}_{\textnormal{\begin{footnotesize}$c$~штук\end{footnotesize}}}
\underbrace{\texttt{DD}\dots\texttt{D}}_{\textnormal{\begin{footnotesize}$d$~штук\end{footnotesize}}}$"
і $n{-}1$ разів застосувати `next_permutation(s.begin(), s.end());`.
Складність такого алгоритму становить $\Theta(n)$ (причому,
`next_permutation`, хоч і має амортизовану складність $\Theta(1)$,
не дуже швидка), тож він ніяк не може бути досить ефективним при
$n\dib{{\approx}}\overline{P}(5,5,5,5)\dib{{=}}\ifBigStretch\displaystyle\fi\frac{20!}{5!\cdot5!\cdot5!\cdot5!}\dib{{\approx}}{1{,}173\cdot10^{10}}$.
В умові задачі нема розбаловки, тож не ясно, що це са́ме%; але очевидно,
що якісь бали мусять бути.

Автори збірника не впевнені, чи достатньо дослідили бібліотеки інших мов
програмування, але хоч трохи схожі засоби вдалося знайти лише у Python
(клас `permutations` модуля `itertools`). Причому, цей клас не так,
як треба, працює з повтореннями елементів, тож невідомо, як використати
його краще, ніж `a = list(set(permutations(s)))`, `a.sort()`, тобто
спочатку згенерувати геть усі перестановки (звичайні), потім використати
`set`, щоб позбутися повторень, потім перетворити у масив (`list`) і
відсортувати. Всеце, звісно, працює *набагато* довше, головним чином,
тому́, що на проміжному етапі генеруються перестановки без повторень, а
їх може бути значно більше: наприклад, при ${a\,{=}\,b\,{=}\,4}$,
${c\,{=}\,d\,{=}\,3}$ маємо $14!\dib{{\approx}}8{,}7{\cdot}10^{10}$
(причому їх треба ще й одночасно тримати у пам'яті) проти
$\frac{14!}{4!4!3!3!}\dib{{\approx}}4{,}2{\cdot}10^6$ (щодлякомп'ютера
небагато, причому вони перебираються одна за одною, не займаючи багато
пам'яті). Цей спосіб набирає 40% балів.

Нажаль, для ще інших мов програмування важко запропонувати простий
спосіб набрати навіть таку частину балів. Цесумно, але: (1) 100%-й
алгоритм можна написати будь-якою з доступних мов програмування;
(2) нікому з учасників незаборонялося вчити й використовуватиC++.

Писати власний аналог `next_permutation` не доцільно, бо потребу́є майже
стількиж зусиль, як ефективний розв'язок початкової задачі, а принести
може, щонайбільше, ті ж%балів. Тим не менш, кому цікаво, може знайти у
літературі чи Інтернеті *алгоритми генерації перестановок*. Є кілька
різних класичних алгоритмів такої генерації. І*одні* з них (які
визначають, що поміняти у поточній перестановці, щоб перейти до
наступної) оптимізовані під відносно швидшу організацію перебору усіх
підряд перестановок (у`next_permutation` са́ме такий). А*інші* (зокрема,
рекурсивні) дозволяють вписування додаткових умов, щоб пропускати
непотрібні. Говорячи про цю задачу, такі модифікації можна кінець кінцем
перетворити до рекурсивної версії рекомендованого способу.
