::: problemAllDefault
Прямокутні суми

У цій задачі, алгоритмічна суть повністю повторює задачу C
\<\<Прямокутні суми\>\> з ІІ (районного/міського) етапу Всеукраїнської
олімпіади з інформатики (програмування) по Черкаській області, що
відбувся 14.12.2019 (коротка суть наведена в цитаті праворуч, детальніше
можна подивитися у змаганні 70 сайту ). Але значна частина технічних
деталей організовані абсолютно інакше. Й мета цього комплекту з двох
задач--- ознайомитися з цим іншим технічним форматом, котрий з
2018/19 н. р. наявний на III (обласному) та IV (фінальному) етапах
Всеукраїнської учнівської олімпіади з інформатики (програмування), але
досі не згадувався на змаганнях, що проводяться в межах .

Розв'язки цієї задачі можна здавати *лише* мовами `g++` (C++), `fpc`
(Free Pascal, у режимі сумісності зDelphi), `javac`(Java). Додавати інші
мови програмування поки що не планується; чи буде це змінено в
майбутньому, невідомо. Скачайте за лінками, вказаними праворуч, файли
згідно Вашої мови програмування.

::: bfseries
::: itshape
Здавати в ejudge на перевірку треба [лише]{.underline} виправлений
[фрагмент]{.underline} програми, відповідний вмісту
[\<\<`sample`\>\>]{.underline}.
:::
:::

Відповідно, редагувати слід у першу чергу його, бо при перевірці на
ejudge будуть використані header та footer, підготовлені журі,
а не відредаговані Вами. (Причому, header буде в точності такий, як
наведено за посиланням, а footer буде дещо відрізнятися, й Вам
не повідомляється, як са́ме.)

*Перелік доступних Вам функцій, підготовлених журі.*

-   `vector<vector<int> > getArray(void)` --- повертає масив, над
    елементами якого потрібно виконувати операції знаходження сум
    прямокутників-запитів. Нумерація рядків та стовпчиків починається
    з 0.

    Якщо Ви виконаєте у своєму коді дію
    `vector<vector<int> > arr = getArray();`, то надалі зможете взнавати
    кількість рядків як `arr.size()`, кількість стовпчиків як
    `arr[0].size()`, значення елемента з індексами `[i][j]` (при
    нумерації з 0) як `arr[i][j]`, тому всі три подальші функції цього
    переліку насправді непотрібні. Але, якщо зручно, можете ними
    користуватися (тоді не обов'язково користуватися цією функцією).

-   `int getHeight(void)` --- повертає кількість рядків у масиві.

-   `int getWidth(void)` --- повертає кількість стовпчиків у масиві.

-   `int getElement(int i, int j)` --- повертає значення елемента,
    розміщеного в `i`-му рядку, `j`-му стовпчику (вважаючи, що нумерація
    рядків та стовпчиків починається з 0). Якщо значення `i` або `j`
    виходять за ме́жі діапазону
    $0\dib{{\<}}\texttt{i}\dib{{<}}\texttt{getHeight()}$,
    $0\dib{{\<}}\texttt{j}\dib{{<}}\texttt{getWidth()}$, виклик
    `getElement(i,j)` повертає 0.

Усі ці функції є просто функціями (а не методами якогось класу).

*Перелік функцій, які Ви зобов'язані реалізувати.*

-   `void init(void)` --- гарантовано буде викликатися один раз, на
    початку (раніше всіх запитів на підрахунок суми прямокутника).
    До результатів діяльності цієї функції ніяких вимог нема, на Ваш
    розсуд.

-   `long long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)`
    --- повинна повернути суму всіх елементів, що потрапляють
    у прямокутник з індексами рядків
    $\texttt{iTop}\dib{{\<}}\texttt{i}\dib{{<}}\texttt{iAfterBottom}$,
    стовпчиків
    $\texttt{jLeft}\dib{{\<}}\texttt{j}\dib{{<}}\texttt{jAfterRight}$
    (нумерація з 0, початок діапазону включно, кінець не включно).

    Це *не* відповідає формату вхідних початкової задачі
    ІІ (районного/міського) етапу (наприклад, прямокутник, який там
    описувався рядком вхідних даних "1 2 3 4", тут описується викликом
    `calcRectSum(0, 2, 2, 4)`); але, на думку автора задачі, для
    мови C++ так якраз природніше.

Обидві ці функції повинні бути просто функціями (а не методами якогось
класу).

Фрагмент header *містить* рядок "`{$mode delphi}`", тому вся компіляція
відбуватиметься в режимі (максимально можливої для Free Pascal)
сумісності з Delphi; зокрема, це забезпечує, що тип `integer`
32-бітовий.

*Перелік доступних Вам типів та підпрограм, підготовлених журі.*

-   `type Arr2D = array[1..5000,1..5000] of integer` --- Ви
    не зобов'язані скрізь користуватися лише такими масивами, але
    наступна процедура використовує са́ме цей тип.

-   `procedure getArray(var arr : Arr2D; var N, M : integer)` --- надає
    переданому масиву той вміст, для елементів якого слід шукати суми
    прямокутників-запитів, а ще двом змінним --- розміри: спочатку (`N`)
    кількість рядків, потім (`M`) кількість стовпчиків. Нумерація рядків
    та стовпчиків починається з 1.

    Оскільки і сам масив, і його розміри тут вже задані, всі три
    подальші функції цього переліку насправді непотрібні. Але, якщо
    зручно, можете ними користуватися (тоді не обов'язково користуватися
    цією процедурою).

-   `function getHeight : integer` --- повертає кількість рядків у
    масиві.

-   `function getWidth : integer` --- повертає кількість стовпчиків у
    масиві.

-   `function getElement(i, j : integer) : integer` --- повертає
    значення елемента, розміщеного в `i`-му рядку, `j`-му стовпчику
    (вважаючи, що нумерація рядків та стовпчиків починається з 1). Якщо
    значення `i` або `j` виходять за ме́жі діапазону
    $1\dib{{\<}}\texttt{i}\dib{{\<}}\texttt{getHeight}$,
    $1\dib{{\<}}\texttt{j}\dib{{\<}}\texttt{getWidth}$, виклик
    `getElement(i,j)` повертає 0.

Усі ці процедури/функції є просто процедурами/функціями (а не методами
якогось класу).

*Перелік підпрограм, які Ви зобов'язані реалізувати.*

-   `procedure init` --- гарантовано буде викликатися один раз, на
    початку (раніше всіх запитів на підрахунок суми прямокутника).
    До результатів діяльності цієї процедури ніяких вимог нема, на Ваш
    розсуд.

-   `function calcRectSum(iTop, iBottom, jLeft, jRight : integer) : int64`
    --- повинна повернути суму всіх елементів, що потрапляють
    у прямокутник з індексами рядків
    $\texttt{iTop}\dib{{\<}}\texttt{i}\dib{{\<}}\texttt{iBottom}$,
    стовпчиків
    $\texttt{jLeft}\dib{{\<}}\texttt{j}\dib{{\<}}\texttt{jRight}$
    (нумерація з 1, усі ме́жі включно; це якраз відповідає формату
    вхідних початкової задачі ІІ (районного/міського) етапу,
    і вважається природнім для мови Pascal).

Ці процедура та функція повинні бути просто процедурою та функцією
(а не методами якогось класу).

*Перелік доступних Вам методів, підготовлених журі.* Всі ці ме́тоди є
статичними публічними класу `GetData`.

-   `static public int[][] getArray()` --- повертає двовимірний масив
    (масив масивів), над елементами якого потрібно виконувати операції
    знаходження сум прямокутників-запитів. Нумерація рядків та
    стовпчиків починається з 0.

    Якщо Ви виконаєте у своєму коді дію
    `int[][] arr = GetData.getArray();`, то надалі зможете взнавати
    кількість рядків як `arr.length`, кількість стовпчиків як
    `arr[0].length`, значення елемента з індексами `[i][j]` (при
    нумерації з 0) як `arr[i][j]`, тому всі три подальші методи цього
    переліку насправді непотрібні. Але, якщо зручно, можете ними
    користуватися (тоді не обов'язково користуватися цим методом).

-   `static public int getHeight()` --- повертає кількість рядків у
    масиві.

-   `static public int getWidth()` --- повертає кількість стовпчиків у
    масиві.

-   `static public int getElement(int i, int j)` --- повертає значення
    елемента, розміщеного в `i`-му рядку, `j`-му стовпчику (вважаючи, що
    нумерація рядків та стовпчиків починається з 0). Якщо значення `i`
    або `j` виходять за ме́жі діапазону
    $0\dib{{\<}}\texttt{i}\dib{{<}}\texttt{GetData.getHeight()}$,
    $0\dib{{\<}}\texttt{j}\dib{{<}}\texttt{GetData.getWidth()}$, виклик
    `GetData.getElement(i,j)` повертає 0.

Всі згадані тут ме́тоди є статичними публічними класу `GetData`.

*Перелік методів, які Ви зобов'язані реалізувати.* Всі ці ме́тоди повинні
бути статичними публічними класу `UserSolver`. Весь клас повинен
[*не*]{.underline} бути публічним.

-   `static public void init()` --- гарантовано буде викликатися один
    раз, на початку (раніше всіх запитів на підрахунок суми
    прямокутника). До результатів діяльності цього ме́тода ніяких вимог
    нема, на Ваш розсуд.

-   `static public long calcRectSum(int iTop, int iAfterBottom, int jLeft, int jAfterRight)`
    --- повинна повернути суму всіх елементів, що потрапляють
    у прямокутник з індексами рядків
    $\texttt{iTop}\dib{{\<}}\texttt{i}\dib{{<}}\texttt{iAfterBottom}$,
    $\texttt{jLeft}\dib{{\<}}\texttt{j}\dib{{<}}\texttt{jAfterRight}$
    (нумерація з 0, початок діапазону включно, кінець не включно).

    Це *не* відповідає формату вхідних початкової задачі
    ІІ (районного/міського) етапу (наприклад, прямокутник, який там
    описувався рядком вхідних даних "1 2 3 4", тут описується викликом
    `UserSolver.calcRectSum(0, 2, 2, 4)`); але, на думку автора задачі,
    для мови Java так якраз природніше.

Всі згадані тут ме́тоди повинні бути статичними публічними класу
`UserSolver`. Весь клас повинен [*не*]{.underline} бути публічним.
Ви можете, якщо бажаєте, додавати у клас `UserSolver` свої ме́тоди та/або
поля́, робити їх будь-якого рівня доступу
(`public`/`protected`/`private`), але обов'язково *лише статичними*.
Примірники (instances) цього класу створюватися
[*не*]{.underline} будуть.

Оцінювання поблокове (бали за блок нараховуються лише в разі успішного
проходження всіх тестів блоку). Стовпчик \<\<передумови\>\> означає, що
розв'язок запускатиметься і перевірятиметься на поточному блоці, лише
якщо цей самий розв'язок успішно пройшов блоки, згадані в передумовах.
Нерівності через кому (як-то \<\<${100\,{\<}\,N,M\,{\<}\,400}$\>\>)
означають, що всі перелічені через кому змінні перебувають в указаному
діапазоні. Обмеження на "$T$" вказують можливу кількість викликів
`calcRectSum` для однієї й тієї ж таблиці. Обмеження на "$a_{ij}$"
вказують можливі значення елементів таблиці.

У блоках 1 та 2 тести рівносильні відповідним тестам задачі C
\<\<Прямокутні суми\>\> ІІ (районного/міського) етапу Всеукраїнської
олімпіади з інформатики по Черкаській області, що відбувся 14.12.2019;
зокрема, 1-йтест 1-гоблоку відповідає тесту, який там наведений в умові.
В подальших блоках тести інші.
:::
